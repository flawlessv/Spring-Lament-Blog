# è¯¦ç»†è®²è§£Formç»„ä»¶çš„ä¾èµ–å…³ç³»

_Exported on 2025/7/16 at GMT+8 21:07:57 from Cursor (1.2.4)_

---

**User**

@/schema-components ç»™æˆ‘è®²æ¸…æ¥šè¿™ä¸ªç»„ä»¶åº“Formçš„å€¼ä¾èµ–ï¼Œpropsä¾èµ–ä»¥åŠå­—æ®µä¾èµ–æ˜¯æ€ä¹ˆå®ç°çš„ï¼Œè¦æ±‚æ–‡æ¡£çº§çº§åˆ«ç»™æˆ‘é˜è¿°æ¸…æ¥š

---

**Cursor**

æˆ‘æ¥å¸®æ‚¨è¯¦ç»†åˆ†æ schema-components ç»„ä»¶åº“ä¸­ Form çš„ä¾èµ–å®ç°æœºåˆ¶ã€‚è®©æˆ‘å…ˆæ¢ç´¢ä¸€ä¸‹ä»£ç ç»“æ„ï¼Œäº†è§£å…·ä½“çš„å®ç°ç»†èŠ‚ã€‚

# Schema-Components Form ä¾èµ–æœºåˆ¶æ·±åº¦è§£æ

åŸºäºæˆ‘å¯¹ä»£ç çš„æ·±å…¥åˆ†æï¼Œç°åœ¨ä¸ºæ‚¨è¯¦ç»†é˜è¿° schema-components ç»„ä»¶åº“ä¸­ Form çš„ä¸‰ç§ä¾èµ–å®ç°æœºåˆ¶ã€‚

## ğŸ—ï¸ æ•´ä½“æ¶æ„æ¦‚è§ˆ

Schema-Components çš„ Form ä¾èµ–ç³»ç»ŸåŸºäºä»¥ä¸‹æ ¸å¿ƒç»„ä»¶æ„å»ºï¼š

```mermaid
graph TD
    A[å­—æ®µåˆ›å»ºå™¨ FieldCreator] --> B[ä¾èµ–é…ç½® dependency]
    B --> C[å€¼ä¾èµ– value]
    B --> D[Propsä¾èµ– props]
    B --> E[å­—æ®µä¾èµ– fields]

    F[è®¢é˜…ç³»ç»Ÿ Subscription] --> G[useSubscribe Hook]
    G --> H[FormItemElWrapper]
    H --> I[ä¾èµ–ç›‘å¬ä¸å¤„ç†]

    J[æ‰¹é‡æ›´æ–° BatchDepUpdate] --> K[æ€§èƒ½ä¼˜åŒ–]

    I --> L[åŠ¨æ€å­—æ®µæ¸²æŸ“]
    I --> M[åŠ¨æ€å€¼è®¡ç®—]
    I --> N[åŠ¨æ€å±æ€§æ›´æ–°]
```

## ğŸ“‹ ä¸€ã€å€¼ä¾èµ– (Value Dependency) å®ç°æœºåˆ¶

### 1.1 æ ¸å¿ƒåŸç†

å€¼ä¾èµ–é€šè¿‡ç›‘å¬æŒ‡å®šå­—æ®µçš„å˜åŒ–ï¼Œè‡ªåŠ¨è®¡ç®—å¹¶æ›´æ–°å½“å‰å­—æ®µçš„å€¼ã€‚

### 1.2 API è®¾è®¡

```typescript
// å­—æ®µåˆ›å»ºå™¨ä¸­çš„å€¼ä¾èµ–æ–¹æ³•
DependencyValue<Key extends string>(
  deps: Key[],
  depFn: DependencyValueFn<AnyObject, Key>
) {
  this._mergeVal({ dependency: { deps, value: depFn } })
  return this
}
```

### 1.3 ä½¿ç”¨ç¤ºä¾‹

```typescript
F("å€¼ä¾èµ–å­—æ®µ", "combinedValue").DependencyValue(
  ["gender", "hobby"],
  (depValues, ctx) => {
    // depValues: { gender: 'male', hobby: 'basketball' }
    // ctx: { allValues, changedDepKeys, formRef, batchUpdate }
    return [depValues.gender, depValues.hobby].filter(Boolean).join("-");
  }
);
```

### 1.4 åº•å±‚å®ç°æœºåˆ¶

**1. ä¾èµ–ç›‘å¬è®¾ç½®**

```typescript
// FormItemElWrapper.tsx ä¸­çš„å®ç°
const deps = field.dependency?.fields ? undefined : field.dependency?.deps;
const { allDepValues: depValues, changedDepKeys } = useSubscribe<TData>(
  subscription,
  deps
);
```

**2. å€¼è®¡ç®—ä¸æ›´æ–°**

```typescript
useDeepCompareEffect(() => {
  if (deps && deps.length > 0 && depValueFn) {
    // è®¡ç®—æ–°å€¼
    const newValue = (depValueFn as DepValueFn<TData>)(depValues, {
      allValues: formValue.getValue(),
      changedDepKeys,
      formRef,
      batchUpdate: BatchDepUpdate.update,
    });

    // æ‰¹é‡æ›´æ–°å¤„ç†
    const finalValue = BatchDepUpdate.getValues<TData>(
      field.dataIndex,
      newValue
    );

    // å¼‚æ­¥æ›´æ–°é¿å…å¾ªç¯ä¾èµ–
    Schedular.nextMacro(() => {
      formRef.current?.mergeFieldsValue?.(finalValue);
    });
  }
}, [deps, depValues]);
```

### 1.5 ç‰¹æ€§ä¸ä¼˜åŠ¿

- **è‡ªåŠ¨è®¡ç®—**: ä¾èµ–å­—æ®µå˜åŒ–æ—¶è‡ªåŠ¨è§¦å‘å€¼è®¡ç®—
- **æ‰¹é‡æ›´æ–°**: æ”¯æŒä¸€æ¬¡æ€§æ›´æ–°å¤šä¸ªå­—æ®µå€¼
- **å¼‚æ­¥æ›´æ–°**: é¿å…å¾ªç¯ä¾èµ–å’Œæ€§èƒ½é—®é¢˜
- **ç±»å‹å®‰å…¨**: TypeScript å®Œæ•´ç±»å‹æ”¯æŒ

## ğŸ›ï¸ äºŒã€Propsä¾èµ– (Props Dependency) å®ç°æœºåˆ¶

### 2.1 æ ¸å¿ƒåŸç†

Propsä¾èµ–æ ¹æ®ä¾èµ–å­—æ®µçš„å€¼åŠ¨æ€ä¿®æ”¹å­—æ®µç»„ä»¶çš„å±æ€§ï¼ŒåŒ…æ‹¬ `fieldProps`ã€`formItemProps` å’Œ `wrapperProps`ã€‚

### 2.2 API è®¾è®¡

```typescript
// å­—æ®µå±æ€§ä¾èµ–
DependencyMFP<Key extends string, ValueType extends ValueTypePresets = 'text'>(
  type: ValueType,
  deps: Key[],
  depFn: DependencyFieldPropsFn<AnyObject, Key, ExtractGetter<...>>
)

// è¡¨å•é¡¹å±æ€§ä¾èµ–
DependencyMFIP<Key extends string>(
  deps: Key[],
  depFn: DependencyFormItemPropsFn<AnyObject, Key>
)

// åŒ…è£…å™¨å±æ€§ä¾èµ–
DependencyMWP<Key extends string>(
  deps: Key[],
  depFn: DependencyWrapperPropsFn<AnyObject, Key, WrapperProps>
)
```

### 2.3 ä½¿ç”¨ç¤ºä¾‹

```typescript
F("Propsä¾èµ–ç¤ºä¾‹", "dynamicField")
  .DependencyMFIP(["gender"], (depValues) => ({
    labelPlacement: depValues.gender === "male" ? "left" : "right",
  }))
  .DependencyMWP(["gender"], (depValues) => ({
    span: depValues.gender === "male" ? 12 : 24,
  }))
  .DependencyMFP("text", ["gender"], (depValues) => ({
    disabled: depValues.gender === "male",
    readOnly: depValues.gender === "female",
  }));
```

### 2.4 åº•å±‚å®ç°æœºåˆ¶

**1. Propsè®¡ç®—ä¸ç¼“å­˜**

```typescript
// FormItemElWrapper.tsx ä¸­çš„ props ä¾èµ–å¤„ç†
const nextField = useDeepCompareMemo(() => {
  const { field, ...ctx } = depPropsCtxRef.current;
  return generateDepPropsField(field, ctx);
}, [deps, depValues, field, fieldControlState]);
```

**2. åŠ¨æ€å­—æ®µç”Ÿæˆ**

```typescript
function generateDepPropsField<TData extends AnyObject>(
  field: FieldConfigType<TData>,
  ctx: GenerateDepFieldConfigCtxType<TData>
) {
  const {
    fieldProps: depFieldProps,
    wrapperProps: depWrapperProps,
    formItemProps: depFormItemProps,
  } = field.dependency?.props || {};

  if (
    depFieldProps ||
    depWrapperProps ||
    depFormItemProps ||
    fieldControlState
  ) {
    const { depValues, allValues, changedDepKeys, formRef } = ctx;
    const nextCtx = { field, allValues, changedDepKeys, formRef };

    // è®¡ç®—å„ç§å±æ€§
    const fieldProps = (depFieldProps as DepFieldPropsFn<TData>)?.(
      depValues,
      nextCtx
    );
    const formItemProps = (depFormItemProps as DepFormItemPropsFn<TData>)?.(
      depValues,
      nextCtx
    );
    const wrapperProps = (depWrapperProps as DepWrapperPropsFn<TData>)?.(
      depValues,
      nextCtx
    );

    // ä½¿ç”¨å­—æ®µåˆ›å»ºå™¨è¾…åŠ©ç±»åŠ¨æ€æ›´æ–°
    const helper = new FieldCreatorHelper(EditableFieldCreator);
    helper.setInstance(field);
    helper.setPipeGetter("fieldProps", fieldProps);
    helper.setPipeGetter("formItemProps", formItemProps);
    helper.mergeVal({ wrapperProps: wrapperProps || {} });

    return helper.val as FieldConfigType<TData>;
  }

  return field;
}
```

### 2.5 ç‰¹æ€§ä¸ä¼˜åŠ¿

- **ç»†ç²’åº¦æ§åˆ¶**: åˆ†åˆ«æ§åˆ¶å­—æ®µå±æ€§ã€è¡¨å•é¡¹å±æ€§ã€åŒ…è£…å™¨å±æ€§
- **åŠ¨æ€å“åº”**: ä¾èµ–å˜åŒ–æ—¶å®æ—¶æ›´æ–°ç»„ä»¶å±æ€§
- **æ€§èƒ½ä¼˜åŒ–**: åŸºäºæ·±åº¦æ¯”è¾ƒçš„è®°å¿†åŒ–è®¡ç®—
- **çµæ´»é…ç½®**: æ”¯æŒå¤æ‚çš„æ¡ä»¶é€»è¾‘

## ğŸ”„ ä¸‰ã€å­—æ®µä¾èµ– (Fields Dependency) å®ç°æœºåˆ¶

### 3.1 æ ¸å¿ƒåŸç†

å­—æ®µä¾èµ–æ ¹æ®ä¾èµ–å­—æ®µçš„å€¼åŠ¨æ€ç”Ÿæˆå®Œå…¨ä¸åŒçš„å­—æ®µé…ç½®ï¼Œå®ç°å­—æ®µçš„åŠ¨æ€åˆ‡æ¢ã€‚

### 3.2 API è®¾è®¡

```typescript
// ä¸»å­—æ®µä¾èµ– - å®Œå…¨æ›¿æ¢å½“å‰å­—æ®µ
DependencyFields<Key extends string>(
  deps: Key[],
  depFn: DependencyFieldsFn<AnyObject, Key>
) {
  this._setVal('dependency', { deps, fields: depFn })
  return this
}

// å­å­—æ®µä¾èµ– - ç”¨äºå¤æ‚å­—æ®µå†…éƒ¨
ChildDependencyFields<Key extends string>(
  deps: Key[],
  depFn: DependencyFieldsFn<AnyObject, Key>
) {
  this._setVal('dependency', { deps, childFields: depFn })
  return this
}
```

### 3.3 ä½¿ç”¨ç¤ºä¾‹

```typescript
F("çˆ±å¥½(å­—æ®µä¾èµ–)", "hobby").DependencyFields(["gender"], (depValues, ctx) => {
  // æ‰‹åŠ¨é‡ç½®å­—æ®µå€¼é¿å…æ®‹ç•™
  if (ctx.allValues.hobby) {
    ctx.formRef.current?.setFieldsValueAsync({ hobby: null });
  }

  if (depValues.gender === "male") {
    return [
      F("çˆ±å¥½", "hobby")
        .Update()
        .MFP("radio", {
          data: [
            { title: "ç¯®çƒ", id: "basketball" },
            { title: "è¶³çƒ", id: "football" },
          ],
        }).val,
    ];
  } else if (depValues.gender === "female") {
    return [
      F("çˆ±å¥½", "hobby")
        .Update()
        .MFP("radio", {
          data: [
            { title: "æ¸¸æ³³", id: "swimming" },
            { title: "è·‘æ­¥", id: "running" },
          ],
        }).val,
    ];
  }

  return []; // è¿”å›ç©ºæ•°ç»„è¡¨ç¤ºä¸æ¸²æŸ“ä»»ä½•å­—æ®µ
});
```

### 3.4 åº•å±‚å®ç°æœºåˆ¶

**1. å­—æ®µä¾èµ–éªŒè¯**

```typescript
function validateDependency(field: FieldConfigType): void {
  if (!field.dependency) return;

  // æ£€æŸ¥ deps æ˜¯å¦å­˜åœ¨
  if (!field.dependency.deps || !field.dependency.deps.length) {
    console.error(`å­—æ®µ ${field.key} çš„ dependency é…ç½®ç¼ºå°‘å¿…éœ€çš„ deps å±æ€§`);
    return;
  }

  // fields ä¸ value/props äº’æ–¥
  if (field.dependency.fields) {
    if (field.dependency.value || field.dependency.props) {
      field.dependency.value = undefined;
      field.dependency.props = undefined;
      console.error(
        `å­—æ®µ ${field.key} çš„ dependency: fields ä¸èƒ½ä¸ value æˆ– props åŒæ—¶ä½¿ç”¨`
      );
    }
  }
}
```

**2. åŠ¨æ€å­—æ®µå¤„ç†**

```typescript
// FormFieldsMapper.tsx ä¸­çš„ä¾èµ–å¤„ç†
const processDependency = (
  field: FormFieldConfigType
): FormFieldConfigType[] => {
  if (!field.dependency) return [field];

  const { deps } = field.dependency;
  const depFields = field.dependency[
    depFieldsPropName
  ] as typeof field.dependency.fields;

  // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸å…³ä¾èµ–å˜åŒ–
  const hasRelevantChanges = deps.some((dep) => changedDepKeys.includes(dep));

  // ç¼“å­˜æœºåˆ¶ä¼˜åŒ–æ€§èƒ½
  if (!hasRelevantChanges && depFieldsCacheRef.current.has(field.key)) {
    return depFieldsCacheRef.current.get(field.key) || [];
  }

  // è·å–ä¾èµ–å€¼å¹¶æ‰§è¡Œå­—æ®µç”Ÿæˆå‡½æ•°
  const currentDepValues = pick(depValues, deps);

  if (depFields) {
    const _newFields = depFields(currentDepValues, {
      allValues: props.allValues,
      changedDepKeys,
      formRef: props.formRef,
      parentDataIndex: props.parentDataIndex,
    });

    // æ ‡å‡†åŒ–å¹¶ç¼“å­˜ç»“æœ
    const newFields = _newFields.map(
      props.normalizeChildField || dftNormalizeChildField
    );
    depFieldsCacheRef.current.set(field.key, newFields);

    // é€’å½’å¤„ç†æ–°å­—æ®µçš„ä¾èµ–
    return newFields.flatMap(processDependency);
  }

  return [field];
};
```

### 3.5 ç‰¹æ€§ä¸ä¼˜åŠ¿

- **å®Œå…¨åŠ¨æ€**: å¯ä»¥å®Œå…¨æ›¿æ¢å­—æ®µé…ç½®
- **ç¼“å­˜æœºåˆ¶**: é¿å…ä¸å¿…è¦çš„é‡å¤è®¡ç®—
- **é€’å½’æ”¯æŒ**: æ–°ç”Ÿæˆçš„å­—æ®µä¹Ÿå¯ä»¥æœ‰ä¾èµ–
- **çµæ´»æ§åˆ¶**: æ”¯æŒæ¡ä»¶æ€§æ¸²æŸ“å’Œå¤æ‚é€»è¾‘

## âš¡ å››ã€åº•å±‚è®¢é˜…ç³»ç»Ÿ

### 4.1 Subscription ç±»

è¿™æ˜¯æ•´ä¸ªä¾èµ–ç³»ç»Ÿçš„æ ¸å¿ƒï¼Œæä¾›äº†å¼ºå¤§çš„çŠ¶æ€ç®¡ç†å’Œè®¢é˜…èƒ½åŠ›ï¼š

```typescript
export class Subscription<T> {
  // æ ¸å¿ƒæ–¹æ³•
  setValue(newValue: T | ((prev: T) => T)): void;
  mergeValue(patch: PatchType<T>): BatchUpdateResult<T> | null;
  async batchMerge(patch: PatchType<T>): Promise<BatchUpdateResult<T> | null>;
  subscribe(
    listener: EventListenerType<T>,
    opts?: SubscribeOptions
  ): () => void;
}
```

### 4.2 useSubscribe Hook

æä¾›äº† React å‹å¥½çš„è®¢é˜…æ¥å£ï¼š

```typescript
export function useSubscribe<T extends AnyObject, Key extends keyof T = keyof T>(
  subscription: Subscription<T>,
  deps?: Key[]
): SubscribeResult<T, Key> {
  return {
    allDepValues: Pick<T, Key>, // æ‰€æœ‰ä¾èµ–å­—æ®µçš„å€¼
    changedDepKeys: Key[],      // å‘ç”Ÿå˜åŒ–çš„ä¾èµ–å­—æ®µ
    changedDepValues: Partial<Pick<T, Key>> // å˜åŒ–çš„ä¾èµ–å­—æ®µå€¼
  }
}
```

### 4.3 è·¯å¾„è®¢é˜…ä¼˜åŒ–

å¯¹äºå¤æ‚æ•°æ®ç»“æ„ï¼ˆå¦‚è¡¨æ ¼ï¼‰ï¼Œç³»ç»Ÿæ”¯æŒè·¯å¾„è®¢é˜…é¿å…æ€§èƒ½é—®é¢˜ï¼š

```typescript
// è·¯å¾„è®¢é˜…é¿å…å¹¿æ’­ç»™æ•°é‡ä¼—å¤šçš„æœ«ç«¯è®¢é˜…è€…
return subscription.subscribe(listener, {
  path: [
    [0, "name"],
    [1, "age"],
  ], // ä»…è®¢é˜…ç‰¹å®šè·¯å¾„
});
```

## ğŸš€ äº”ã€æ‰¹é‡æ›´æ–°æœºåˆ¶

### 5.1 BatchDepUpdate å·¥å…·ç±»

```typescript
export class BatchDepUpdate {
  // æ ‡è®°ä¸ºæ‰¹é‡æ›´æ–°
  static update<TData extends AnyObject>(values: Partial<TData>) {
    return { _IS_BATCH_UPDATE_: true as const, values };
  }

  // æ£€æŸ¥æ˜¯å¦ä¸ºæ‰¹é‡æ›´æ–°
  static isBatch<TData extends AnyObject>(
    value: unknown
  ): value is BatchUpdatePayloadType<TData>;

  // è·å–æœ€ç»ˆçš„æ›´æ–°å€¼
  static getValues<TData extends AnyObject>(
    key: FieldPath,
    value: unknown
  ): Partial<TData>;
}
```

### 5.2 æ‰¹é‡æ›´æ–°ä¼˜åŠ¿

- **æ€§èƒ½ä¼˜åŒ–**: å¤šä¸ªå­—æ®µå˜åŒ–æ—¶åˆå¹¶ä¸ºä¸€æ¬¡æ›´æ–°
- **é¿å…å¾ªç¯**: é˜²æ­¢ä¾èµ–é“¾é€ æˆçš„æ— é™å¾ªç¯
- **å¼‚æ­¥å¤„ç†**: ä½¿ç”¨å®ä»»åŠ¡é˜Ÿåˆ—é¿å…é˜»å¡

## ğŸ” å…­ã€ä¾èµ–æ‰§è¡Œä¼˜å…ˆçº§ä¸å†²çªå¤„ç†

### 6.1 ä¼˜å…ˆçº§è§„åˆ™

1. **å­—æ®µä¾èµ–** > å€¼ä¾èµ– + Propsä¾èµ–
2. å­—æ®µä¾èµ–ä¼šå®Œå…¨æ›¿æ¢åŸå­—æ®µï¼Œå…¶ä»–ä¾èµ–å¤±æ•ˆ
3. å€¼ä¾èµ–å’Œ Propsä¾èµ–å¯ä»¥åŒæ—¶ä½¿ç”¨

### 6.2 å†²çªæ£€æµ‹

```typescript
// è‡ªåŠ¨æ£€æµ‹å¹¶å¤„ç†å†²çªé…ç½®
if (field.dependency.fields) {
  if (field.dependency.value || field.dependency.props) {
    field.dependency.value = undefined;
    field.dependency.props = undefined;
    console.error("fields ä¸èƒ½ä¸ value æˆ– props åŒæ—¶ä½¿ç”¨");
  }
}
```

## ğŸ¯ ä¸ƒã€æœ€ä½³å®è·µä¸æ³¨æ„äº‹é¡¹

### 7.1 æ€§èƒ½ä¼˜åŒ–å»ºè®®

1. **åˆç†ä½¿ç”¨ç¼“å­˜**: å­—æ®µä¾èµ–ä¼šè‡ªåŠ¨ç¼“å­˜è®¡ç®—ç»“æœ
2. **é¿å…æ·±åº¦ä¾èµ–**: è¿‡æ·±çš„ä¾èµ–é“¾ä¼šå½±å“æ€§èƒ½
3. **æ‰¹é‡æ›´æ–°**: å¤šä¸ªå­—æ®µå˜åŒ–æ—¶ä½¿ç”¨ `batchUpdate`

### 7.2 å¸¸è§é™·é˜±

1. **å¾ªç¯ä¾èµ–**: A ä¾èµ– Bï¼ŒB ä¾èµ– A
2. **å€¼æ®‹ç•™**: å­—æ®µä¾èµ–åˆ‡æ¢æ—¶éœ€è¦æ‰‹åŠ¨é‡ç½®å€¼
3. **å¼‚æ­¥æ—¶åº**: ä¾èµ–è®¡ç®—æ˜¯å¼‚æ­¥çš„ï¼Œæ³¨æ„æ—¶åºé—®é¢˜

### 7.3 æ¨èç”¨æ³•

```typescript
// æ¨èï¼šæ˜ç¡®çš„ä¾èµ–å…³ç³»
F("è®¡ç®—å­—æ®µ", "computed").DependencyValue(
  ["a", "b"],
  (deps) => deps.a + deps.b
);

// æ¨èï¼šæ¡ä»¶æ€§å­—æ®µæ¸²æŸ“
F("åŠ¨æ€å­—æ®µ", "dynamic").DependencyFields(["type"], (deps) => {
  return deps.type === "advanced" ? advancedFields : basicFields;
});

// æ¨èï¼šå“åº”å¼å±æ€§æ›´æ–°
F("å“åº”å¼å­—æ®µ", "responsive").DependencyMFP("select", ["category"], (deps) => ({
  data: getOptionsByCategory(deps.category),
}));
```

## ğŸ“Š å…«ã€æ€»ç»“

Schema-Components çš„ Form ä¾èµ–ç³»ç»Ÿé€šè¿‡ä»¥ä¸‹æ ¸å¿ƒæœºåˆ¶å®ç°äº†å¼ºå¤§è€Œçµæ´»çš„è¡¨å•åŠ¨æ€èƒ½åŠ›ï¼š

1. **è®¢é˜…é©±åŠ¨**: åŸºäº Subscription ç±»çš„å“åº”å¼çŠ¶æ€ç®¡ç†
2. **ä¸‰ç§ä¾èµ–**: å€¼ä¾èµ–ã€Propsä¾èµ–ã€å­—æ®µä¾èµ–æ»¡è¶³ä¸åŒåœºæ™¯
3. **æ€§èƒ½ä¼˜åŒ–**: ç¼“å­˜ã€æ‰¹é‡æ›´æ–°ã€è·¯å¾„è®¢é˜…ç­‰ä¼˜åŒ–ç­–ç•¥
4. **ç±»å‹å®‰å…¨**: å®Œæ•´çš„ TypeScript ç±»å‹æ”¯æŒ
5. **æ˜“ç”¨ API**: é€šè¿‡å­—æ®µåˆ›å»ºå™¨æä¾›é“¾å¼è°ƒç”¨æ¥å£

è¿™å¥—ä¾èµ–ç³»ç»Ÿä¸ºå¤æ‚è¡¨å•åœºæ™¯æä¾›äº†å®Œæ•´çš„è§£å†³æ–¹æ¡ˆï¼Œæ”¯æŒä»ç®€å•çš„å€¼è®¡ç®—åˆ°å¤æ‚çš„å­—æ®µåŠ¨æ€ç”Ÿæˆï¼Œæ˜¯ä¸€ä¸ªè®¾è®¡ç²¾è‰¯çš„ä¼ä¸šçº§è¡¨å•è§£å†³æ–¹æ¡ˆã€‚

```plaintext
graph TD
    A[å­—æ®µåˆ›å»ºå™¨ FieldCreator] --> B[ä¾èµ–é…ç½® dependency]
    B --> C[å€¼ä¾èµ– value]
    B --> D[Propsä¾èµ– props]
    B --> E[å­—æ®µä¾èµ– fields]

    F[è®¢é˜…ç³»ç»Ÿ Subscription] --> G[useSubscribe Hook]
    G --> H[FormItemElWrapper]
    H --> I[ä¾èµ–ç›‘å¬ä¸å¤„ç†]

    J[æ‰¹é‡æ›´æ–° BatchDepUpdate] --> K[æ€§èƒ½ä¼˜åŒ–]

    I --> L[åŠ¨æ€å­—æ®µæ¸²æŸ“]
    I --> M[åŠ¨æ€å€¼è®¡ç®—]
    I --> N[åŠ¨æ€å±æ€§æ›´æ–°]
```

```typescript
// å­—æ®µåˆ›å»ºå™¨ä¸­çš„å€¼ä¾èµ–æ–¹æ³•
DependencyValue<Key extends string>(
  deps: Key[],
  depFn: DependencyValueFn<AnyObject, Key>
) {
  this._mergeVal({ dependency: { deps, value: depFn } })
  return this
}
```

```typescript
F("å€¼ä¾èµ–å­—æ®µ", "combinedValue").DependencyValue(
  ["gender", "hobby"],
  (depValues, ctx) => {
    // depValues: { gender: 'male', hobby: 'basketball' }
    // ctx: { allValues, changedDepKeys, formRef, batchUpdate }
    return [depValues.gender, depValues.hobby].filter(Boolean).join("-");
  }
);
```

```typescript
// FormItemElWrapper.tsx ä¸­çš„å®ç°
const deps = field.dependency?.fields ? undefined : field.dependency?.deps;
const { allDepValues: depValues, changedDepKeys } = useSubscribe<TData>(
  subscription,
  deps
);
```

```typescript
useDeepCompareEffect(() => {
  if (deps && deps.length > 0 && depValueFn) {
    // è®¡ç®—æ–°å€¼
    const newValue = (depValueFn as DepValueFn<TData>)(depValues, {
      allValues: formValue.getValue(),
      changedDepKeys,
      formRef,
      batchUpdate: BatchDepUpdate.update,
    });

    // æ‰¹é‡æ›´æ–°å¤„ç†
    const finalValue = BatchDepUpdate.getValues<TData>(
      field.dataIndex,
      newValue
    );

    // å¼‚æ­¥æ›´æ–°é¿å…å¾ªç¯ä¾èµ–
    Schedular.nextMacro(() => {
      formRef.current?.mergeFieldsValue?.(finalValue);
    });
  }
}, [deps, depValues]);
```

```typescript
// å­—æ®µå±æ€§ä¾èµ–
DependencyMFP<Key extends string, ValueType extends ValueTypePresets = 'text'>(
  type: ValueType,
  deps: Key[],
  depFn: DependencyFieldPropsFn<AnyObject, Key, ExtractGetter<...>>
)

// è¡¨å•é¡¹å±æ€§ä¾èµ–
DependencyMFIP<Key extends string>(
  deps: Key[],
  depFn: DependencyFormItemPropsFn<AnyObject, Key>
)

// åŒ…è£…å™¨å±æ€§ä¾èµ–
DependencyMWP<Key extends string>(
  deps: Key[],
  depFn: DependencyWrapperPropsFn<AnyObject, Key, WrapperProps>
)
```

```typescript
F("Propsä¾èµ–ç¤ºä¾‹", "dynamicField")
  .DependencyMFIP(["gender"], (depValues) => ({
    labelPlacement: depValues.gender === "male" ? "left" : "right",
  }))
  .DependencyMWP(["gender"], (depValues) => ({
    span: depValues.gender === "male" ? 12 : 24,
  }))
  .DependencyMFP("text", ["gender"], (depValues) => ({
    disabled: depValues.gender === "male",
    readOnly: depValues.gender === "female",
  }));
```

```typescript
// FormItemElWrapper.tsx ä¸­çš„ props ä¾èµ–å¤„ç†
const nextField = useDeepCompareMemo(() => {
  const { field, ...ctx } = depPropsCtxRef.current;
  return generateDepPropsField(field, ctx);
}, [deps, depValues, field, fieldControlState]);
```

```typescript
function generateDepPropsField<TData extends AnyObject>(
  field: FieldConfigType<TData>,
  ctx: GenerateDepFieldConfigCtxType<TData>
) {
  const {
    fieldProps: depFieldProps,
    wrapperProps: depWrapperProps,
    formItemProps: depFormItemProps,
  } = field.dependency?.props || {};

  if (
    depFieldProps ||
    depWrapperProps ||
    depFormItemProps ||
    fieldControlState
  ) {
    const { depValues, allValues, changedDepKeys, formRef } = ctx;
    const nextCtx = { field, allValues, changedDepKeys, formRef };

    // è®¡ç®—å„ç§å±æ€§
    const fieldProps = (depFieldProps as DepFieldPropsFn<TData>)?.(
      depValues,
      nextCtx
    );
    const formItemProps = (depFormItemProps as DepFormItemPropsFn<TData>)?.(
      depValues,
      nextCtx
    );
    const wrapperProps = (depWrapperProps as DepWrapperPropsFn<TData>)?.(
      depValues,
      nextCtx
    );

    // ä½¿ç”¨å­—æ®µåˆ›å»ºå™¨è¾…åŠ©ç±»åŠ¨æ€æ›´æ–°
    const helper = new FieldCreatorHelper(EditableFieldCreator);
    helper.setInstance(field);
    helper.setPipeGetter("fieldProps", fieldProps);
    helper.setPipeGetter("formItemProps", formItemProps);
    helper.mergeVal({ wrapperProps: wrapperProps || {} });

    return helper.val as FieldConfigType<TData>;
  }

  return field;
}
```

```typescript
// ä¸»å­—æ®µä¾èµ– - å®Œå…¨æ›¿æ¢å½“å‰å­—æ®µ
DependencyFields<Key extends string>(
  deps: Key[],
  depFn: DependencyFieldsFn<AnyObject, Key>
) {
  this._setVal('dependency', { deps, fields: depFn })
  return this
}

// å­å­—æ®µä¾èµ– - ç”¨äºå¤æ‚å­—æ®µå†…éƒ¨
ChildDependencyFields<Key extends string>(
  deps: Key[],
  depFn: DependencyFieldsFn<AnyObject, Key>
) {
  this._setVal('dependency', { deps, childFields: depFn })
  return this
}
```

```typescript
F("çˆ±å¥½(å­—æ®µä¾èµ–)", "hobby").DependencyFields(["gender"], (depValues, ctx) => {
  // æ‰‹åŠ¨é‡ç½®å­—æ®µå€¼é¿å…æ®‹ç•™
  if (ctx.allValues.hobby) {
    ctx.formRef.current?.setFieldsValueAsync({ hobby: null });
  }

  if (depValues.gender === "male") {
    return [
      F("çˆ±å¥½", "hobby")
        .Update()
        .MFP("radio", {
          data: [
            { title: "ç¯®çƒ", id: "basketball" },
            { title: "è¶³çƒ", id: "football" },
          ],
        }).val,
    ];
  } else if (depValues.gender === "female") {
    return [
      F("çˆ±å¥½", "hobby")
        .Update()
        .MFP("radio", {
          data: [
            { title: "æ¸¸æ³³", id: "swimming" },
            { title: "è·‘æ­¥", id: "running" },
          ],
        }).val,
    ];
  }

  return []; // è¿”å›ç©ºæ•°ç»„è¡¨ç¤ºä¸æ¸²æŸ“ä»»ä½•å­—æ®µ
});
```

```typescript
function validateDependency(field: FieldConfigType): void {
  if (!field.dependency) return;

  // æ£€æŸ¥ deps æ˜¯å¦å­˜åœ¨
  if (!field.dependency.deps || !field.dependency.deps.length) {
    console.error(`å­—æ®µ ${field.key} çš„ dependency é…ç½®ç¼ºå°‘å¿…éœ€çš„ deps å±æ€§`);
    return;
  }

  // fields ä¸ value/props äº’æ–¥
  if (field.dependency.fields) {
    if (field.dependency.value || field.dependency.props) {
      field.dependency.value = undefined;
      field.dependency.props = undefined;
      console.error(
        `å­—æ®µ ${field.key} çš„ dependency: fields ä¸èƒ½ä¸ value æˆ– props åŒæ—¶ä½¿ç”¨`
      );
    }
  }
}
```

```typescript
// FormFieldsMapper.tsx ä¸­çš„ä¾èµ–å¤„ç†
const processDependency = (
  field: FormFieldConfigType
): FormFieldConfigType[] => {
  if (!field.dependency) return [field];

  const { deps } = field.dependency;
  const depFields = field.dependency[
    depFieldsPropName
  ] as typeof field.dependency.fields;

  // æ£€æŸ¥æ˜¯å¦æœ‰ç›¸å…³ä¾èµ–å˜åŒ–
  const hasRelevantChanges = deps.some((dep) => changedDepKeys.includes(dep));

  // ç¼“å­˜æœºåˆ¶ä¼˜åŒ–æ€§èƒ½
  if (!hasRelevantChanges && depFieldsCacheRef.current.has(field.key)) {
    return depFieldsCacheRef.current.get(field.key) || [];
  }

  // è·å–ä¾èµ–å€¼å¹¶æ‰§è¡Œå­—æ®µç”Ÿæˆå‡½æ•°
  const currentDepValues = pick(depValues, deps);

  if (depFields) {
    const _newFields = depFields(currentDepValues, {
      allValues: props.allValues,
      changedDepKeys,
      formRef: props.formRef,
      parentDataIndex: props.parentDataIndex,
    });

    // æ ‡å‡†åŒ–å¹¶ç¼“å­˜ç»“æœ
    const newFields = _newFields.map(
      props.normalizeChildField || dftNormalizeChildField
    );
    depFieldsCacheRef.current.set(field.key, newFields);

    // é€’å½’å¤„ç†æ–°å­—æ®µçš„ä¾èµ–
    return newFields.flatMap(processDependency);
  }

  return [field];
};
```

```typescript
export class Subscription<T> {
  // æ ¸å¿ƒæ–¹æ³•
  setValue(newValue: T | ((prev: T) => T)): void;
  mergeValue(patch: PatchType<T>): BatchUpdateResult<T> | null;
  async batchMerge(patch: PatchType<T>): Promise<BatchUpdateResult<T> | null>;
  subscribe(
    listener: EventListenerType<T>,
    opts?: SubscribeOptions
  ): () => void;
}
```

```typescript
export function useSubscribe<T extends AnyObject, Key extends keyof T = keyof T>(
  subscription: Subscription<T>,
  deps?: Key[]
): SubscribeResult<T, Key> {
  return {
    allDepValues: Pick<T, Key>, // æ‰€æœ‰ä¾èµ–å­—æ®µçš„å€¼
    changedDepKeys: Key[],      // å‘ç”Ÿå˜åŒ–çš„ä¾èµ–å­—æ®µ
    changedDepValues: Partial<Pick<T, Key>> // å˜åŒ–çš„ä¾èµ–å­—æ®µå€¼
  }
}
```

```typescript
// è·¯å¾„è®¢é˜…é¿å…å¹¿æ’­ç»™æ•°é‡ä¼—å¤šçš„æœ«ç«¯è®¢é˜…è€…
return subscription.subscribe(listener, {
  path: [
    [0, "name"],
    [1, "age"],
  ], // ä»…è®¢é˜…ç‰¹å®šè·¯å¾„
});
```

```typescript
export class BatchDepUpdate {
  // æ ‡è®°ä¸ºæ‰¹é‡æ›´æ–°
  static update<TData extends AnyObject>(values: Partial<TData>) {
    return { _IS_BATCH_UPDATE_: true as const, values };
  }

  // æ£€æŸ¥æ˜¯å¦ä¸ºæ‰¹é‡æ›´æ–°
  static isBatch<TData extends AnyObject>(
    value: unknown
  ): value is BatchUpdatePayloadType<TData>;

  // è·å–æœ€ç»ˆçš„æ›´æ–°å€¼
  static getValues<TData extends AnyObject>(
    key: FieldPath,
    value: unknown
  ): Partial<TData>;
}
```

```typescript
// è‡ªåŠ¨æ£€æµ‹å¹¶å¤„ç†å†²çªé…ç½®
if (field.dependency.fields) {
  if (field.dependency.value || field.dependency.props) {
    field.dependency.value = undefined;
    field.dependency.props = undefined;
    console.error("fields ä¸èƒ½ä¸ value æˆ– props åŒæ—¶ä½¿ç”¨");
  }
}
```

```typescript
// æ¨èï¼šæ˜ç¡®çš„ä¾èµ–å…³ç³»
F("è®¡ç®—å­—æ®µ", "computed").DependencyValue(
  ["a", "b"],
  (deps) => deps.a + deps.b
);

// æ¨èï¼šæ¡ä»¶æ€§å­—æ®µæ¸²æŸ“
F("åŠ¨æ€å­—æ®µ", "dynamic").DependencyFields(["type"], (deps) => {
  return deps.type === "advanced" ? advancedFields : basicFields;
});

// æ¨èï¼šå“åº”å¼å±æ€§æ›´æ–°
F("å“åº”å¼å­—æ®µ", "responsive").DependencyMFP("select", ["category"], (deps) => ({
  data: getOptionsByCategory(deps.category),
}));
```

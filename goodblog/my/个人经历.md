---
title: 个人项目&实习经历personalexperience
slug: 4ejxiv
excerpt: 个人评价
published: true
featured: true
category: AboutMe
publishedAt: 2024-10-18T00:00:00.000Z
readingTime: 5
---

### 个人评价

我有北京即时设计、杭州e签宝、兑吧三段共9个月前端实习开发经验。涵盖toB & toC业务、React & Vue技术等。
具备扎实的前端功底、在校成绩优异、获得四六级证书、有多项学科竞赛经历和省级荣誉。
在校参加多个前端工作室，分别担任前端讲师、前端开发等工作、完成过多项前端开发真实项目。

热衷于前端技术，积极进取，擅长与同事沟通交流，善于总结经验并撰写高质量博客，同时善于运用AI提升开发效率。

英语六级；第十四届蓝桥杯软件类web应用开发组省一(河南省第七)；中国大学生计算机设计大赛三等奖(纯静态页面获奖)

#### 校园经历

睿翼工坊 前端助教 2022-9 2023-6

在睿翼工坊学习前端基础知识,并帮助导师给同学们讲解前端基础知识,帮助同学们解决前端demo中的问题等

双创空间 2021-11 2022-9

负责整个双创空间的前端项目开发，与工作室的后端小伙伴和导师共同开发维护项目，如《api接口开放平台》《简历魔法屋》等

杭州兑吧网络科技有限公司-前端实习生2024-01 ~ 至今
负责日活2000万的广告落地页、抽奖转盘的迭代开发和多个广告后台的维护；涵盖TOB、TOC & React、Vue项目
封装领取记录无缝滚动动画、广告宣传视差滚动效果、并发下拉搜索等通用组件
统一开发和生产模式下图片转换逻辑、兼容判断元素是否在可视区以提高广告曝光率计算的准确性等
新增ADX移动端版本定向功能，并借助TS枚举、interface、高阶类型对版本号进行分类管理
杭州天谷信息科技有限公司（e签宝）-前端实习生2023-10 ~ 2024-01
个人职责：参与天印电子印章平台的维护及迭代开发，上线需求30+

业务功能：负责AI手绘签名的开发，主动提出扩展优化点并被采纳；开发企业印章批量置顶、搜索功能，预留后续相似需求扩展点等

代码优化：微前端技改实现自动注册子应用，使代码体积减少80%；利用AI和插件优化代码质量，解决50+bug、800+代码异味

团队贡献：沉淀多篇前端文章于天谷社区；技术分享同组人员评价9.2分，获得部门、其他组leader高度评价

北京雪云锐创科技有限公司（即时设计）-前端实习生2023-06 ~ 2023-09
个人职责：负责即时AI1.3版本的页面开发、功能实现、BUG修复和后台管理迭代等

组件封装：响应式模型卡片/轮播图、AI生图参数控制、编辑器社区新手引导等

业务功能：AI生图生成队列（滚动懒加载、实时拖动排序、伪置顶等）、灵感画布侧边栏（可吸附、拖动、边缘检测）等

### 项目经验

#### 简历魔法屋（校科技创新基金会项目） 前端总开发

项目介绍：一款在线简历服务平台，提供简历模板选择、实时编辑、购买服务、在线聊天指导和后台管理等功能

技术栈 ：React18 + Axios + Mui + Reduxjs/toolkit + Websocket + styled-components　**线上地址**：[http://onlyfufu.top](http://onlyfufu.top/)　

前台Github：https://github.com/flawlessv/--V2.0　后台Github：https://github.com/flawlessv/resume_manage

1. 二次封装UI库、透传style、className、props实现组件多处复用；支持双token身份验证，实现**无感刷新**优化用户体验

2. 提供**简历编辑的实时预览**并缓存用户简历数据；通过CSS IN JS 配合服务端实现**同一简历模板不同样式渲染**

3. 支持下单各种简历优化指导服务，包括存疑、评价、退款和删除等操作

4. 支持在线与简历服务师交流，Websocket使用心跳机制，实现断线重连；简历模块支持自定义调整、拖拽等操作

5. 借助React Hooks实现**组件最小原子渲染**；简历模板使用**虚拟列表**渲染；首页通过图片、路由懒加载使首屏渲染时间缩短约61%

Geek之窗

项目描述：从0到1自实现的 web 终端项目，用户可在一个页面通过输入命令快速完成所有操作，开发者可以轻松自由地定制新命令

1.基于 Vue 3 + Vite + Ant Design 实现响应式 web终端页面；基于 NodeJS + Express + Sequelize ORM 实现后端

2.自主设计 web 终端、命令系统以及命令集 3 个子系统，使得整个系统逻辑清晰、职责分明

3.web 终端模块：采用 Vue3 Composition API 向终端集成历史命令、提示、快捷键等功能，使系统更易于维护

4.命令系统：采用匹配 => 解析 (getOps 库) => 执行机制实现，并通过递归的方式实现子命令解析

6.为了更方便地管理用户配置(比如背景、提示语)，使用 Pinia 全局管理器，实现多组件复用变量以及LocalStorage 自动持久化

腾讯云

360

吉比特（待笔试）

腾讯--3.26一面

**小米 --3.12笔试-3.22一面 3.26二面**

快手--3.29一面

字节 -- 3月12一面--3.14二面--3.25三面

滴滴--3.27一面

涂鸦智能--hr面完泡池子

知乎

58

哈罗猫眼（秋招二面挂）
莉莉丝、

金山-（简历挂挂）

~~cvte --3.5笔试(笔试挂)~~
~~帆软~~

~~恒生（简历挂挂）~~

~~微派（秋招一面挂）（简历挂）~~

~~美团--3.9笔试（没做）~~

~~科大讯飞（不想做测评）~~

~~xmind（简历挂挂）~~

~~大华~~

~~tp-link~~

~~蚂蚁（内推）（简历挂挂）~~

~~贝壳（简历挂挂）~~

**即时设计**-oc

数字马力-offer

八股（html、css、js、ts、react 、408）、手写题、算法题、项目、实习（123段）

八股：

- 从浏览器地址栏输入 url 到请求返回发生了什么？

- DNS域名解析的过程
- DNS迭代查询和递归查询的区别？
- tcp连接 为什么需要三次？两次和四次不行吗？
- tcp为什么是怎么保证可靠传输的
- 如何实现一个tcp？❌
- cdn是如何实现的 ❌
- 常见的网络加密算法有什么
- 进程和线程的区别
- 进程的通信方法
- 如何避免内存分配碎片化 ❌
- pcb是由那些组成的

项目：

- 最有挑战的项目经历
- 什么叫双token身份验证
- token有效期多久？refreshToken时间多久 ❌
- 有其他的形式保持登陆态吗？不依赖后端可不可以保持登陆态？❌
- 如果想要保持30天的登陆态？用cookie还是session？
- cookie和session的区别是什么？❌
- cookie是怎么做到每次请求都带上的
- 为什么要选用css in js这项技术？一些站点的换肤会用这项技术么？为什么不用裸css
- 用websocket主要去做什么？怎么实现数据传输？❌
- 简历模块自定义拖拽怎么实现的？防抖？应该加多少ms？
- 怎么让一个元素实现被她可以拖拽？（draggable）
- 怎么更改拖拽元素之后的样式（拖拽之后原本的元素已经不存在，改变样式要加个定时器-等到rerender之后再改变样式）
- 虚拟列表怎么做的？
- 图片使首屏渲染减少了多少ms？你怎么计算首屏渲染时间的（图片加载并不会减少首屏渲染） ❌
- 路由懒加载是怎么实现的？
  手撕
- 一个easy的动态规划
- 一个虚拟列表（用react封装）

### 自我介绍

​ 面试官您好,我叫赵世伟。目前是24年应届本科生。我的话是从大二就开始学前端,我这边计算机基础和前端基础都是比较扎实的，并且项目经验和实习经验也是比较丰富的。
在校期间，我取得了较好的成绩排名，并在大二时顺利通过了四六级考试。此外，我还积极参与了各种计算机竞赛，并荣获了一些省级奖项。在校我加入了两个与前端相关的部门。在第一个部门我不仅学习和实践了前端基础知识，并且担任前端助教的职位帮助别的同学们解答疑惑。在第二个部门，我与导师和工作室的后端小伙伴一起合作开发项目。其中有一个就是我们学校的校科技创新基金会项目，叫简历魔法屋，这个项目的整个前端工作都是我一个人独立开发负责的。该平台的主要功能包括用户可以在线选择简历模板、实时编辑简历、下载简历，并且还可以购买简历服务让简历规划师去辅导用户优化简历，此外用户还可以对他的订单进行评价、退款、存疑等等操作。

其次我这边有过三段前端实习经历，涵盖了TOB、TOC业务 React和Vue框架等。第一段是在北京的即时设计：主要负责前端AI方向的业务开发。第二段是在杭州e签宝，主要做电子签名，电子印章，电子合同之类的业务。第三段是在杭州兑吧网络科技有限公司，主要做的就是广告投放、抽奖相关的业务。 uiihi bj h

#### 难点：

##### 1. 双token怎么用的？原理是什么？

[双token机制](https://blog.csdn.net/qq_41634455/article/details/112591318?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168518660616800225587319%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=168518660616800225587319&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-112591318-null-null.142^v88^control_2,239^v2^insert_chatgpt&utm_term=%E5%8F%8Ctoken%E6%9C%BA%E5%88%B6&spm=1018.2226.3001.4187)

###### 1.1 单`token`的缺点

​ 如果是单`token`的话，用户在使用`app`或者在网页上进行操作时，你的`token`突然就过期了，然后只好被迫停止现在正在进行的操作跳转到登录页进行重新登录操作一种非常不好的体验。

###### 1.2 为什么不把`token`时间设置的很长

​ `token`本就是为了减少未经保护的敏感信息在网络中的传递而设置的，同时也方便了登录态的检验，但是如果`token`设置的过期时间相当的长，那么`token`和帐号的安全性变得几乎没有意义，

###### 1.3 何为双`token`验证

​ 顾名思义，就是在登陆操作之后由服务端返回两个`token`：`accessToken`和`refreshToken`，在之后的验证登录态的操作中使用这两个token进行验证，其中`accessToken`的过期时间相当短，`refreshToken`的过期时间相对于`accessToken`而言相当长，且会不断的刷新，每次刷新后的`refreshToken`都是不同的

###### 1.4 双`token`验证的优点

- `accessToken`的存在，保证了登录态的正常验证，因其过期时间的短暂也保证了帐号的安全性
- `refreshToekn`的存在，保证了用户（即使是非活跃用户）无需在短时间内进行反复的登陆操作来保证登录态的有效性，同时也保证了活跃用户的登录态可以一直存续而不需要进行重新登录，其反复刷新也防止某些不怀好意的人获取`refreshToken`后对用户帐号进行非法操作

###### 1.5 双`token`检验流程

首先进行正常的登录操作，在后台服务器验证账号密码成功之后返回2个`token`：`accessToken`和`refreshToken`。在进行服务器请求的时候，先将`Token`发送验证，如果`accessToken`有效，则正常返回请求结果；如果`accessToken`无效，则验证`refreshToken`。此时如果`refreshToken`有效则返回请求结果和新的`accessToken`和新的`refreshToken`。如果`refreshToken`无效，则提示用户进行重新登陆操作。

###### 1.6 前端token通常保存在哪里，有什么优缺点

前端Token通常保存在浏览器中，可以选择在cookies、local storage或session storage这些位置存储。其中，使用cookie保存Token是最常见和推荐的方式。

- 优点：

1. 前端Token通过HTTP请求头发送到服务器，比传统的cookies更加安全，并且能够与跨域资源共享（`CORS`）一起使用。
2. 在Cookies中保存Token，可以在不同页面之间进行共享，方便用户在应用程序中进行导航和流程操作。
3. Cookies支持从服务器设置过期时间、路径、域和安全标志等，使得管理和控制Token更加容易和灵活。

- 缺点：

1. 在cookies中保存Token，可能会被跨站脚本攻击（`XSS`）获取到，进而篡改用户信息、冒充用户行为等。
2. 长期保存Token，可能会被盗取，进而被恶意利用。
3. 存储在Cookies中的Token不能跨域共享，因此必须要在每个相关域名下再次设置和存储Token，增加开发量和维护难度。

总体来说，尽管存在一些安全风险，但使用Cookies保存前端Token仍然是常见和有效的方案，特别是相较于其他两种方式来说，它可以提供更好的跨域访问和可靠的Token管理。

Cookie 和 Session 是 Web 应用中用于跟踪用户状态和存储用户数据的两种机制。它们有以下区别：

1. 存储位置：Cookie 存储在客户端（浏览器）中，而 Session 存储在服务器端。
2. 数据存储方式：Cookie 通过在客户端存储键值对的方式来存储数据，而 Session 通过在服务器端存储会话数据，并为每个会话分配一个唯一的标识符（Session ID）。
3. 安全性：由于 Cookie 存储在客户端，并且可以被客户端修改，因此它们的安全性较低。为了增加安全性，可以对 Cookie 进行加密和签名。而 Session 存储在服务器端，客户端只有通过 Session ID 来访问会话数据，因此相对更安全。
4. 存储容量：Cookie 的存储容量较小，一般限制在几 KB 到几十 KB。而 Session 的存储容量一般较大，可以存储更多的数据。
5. 生命周期：Cookie 可以设置过期时间，从而控制其生命周期。一旦 Cookie 过期，客户端将不再发送该 Cookie。而 Session 的生命周期由服务器管理，可以在用户访问网站时创建，并在一定时间内保持活动状态，直到过期或被服务器终止。
6. 跨域支持：Cookie 可以在跨域请求中发送，但需要遵循同源策略。服务器可以设置 Cookie 的域和路径，以限制其在哪些域和路径下可被发送。而 Session 通常与特定的域和路径绑定，不容易在跨域请求中共享。

总体而言，Cookie 用于在客户端存储少量的数据，以便在请求之间跟踪用户状态。而 Session 则用于在服务器端存储更多的用户数据，并为每个用户提供一个唯一的会话标识符。它们在安全性、存储位置和生命周期等方面有所不同，可以根据具体的需求选择使用哪种机制。

##### 2. 函数式组件闭包

在使用手机号登录或注册的时候，会涉及到一个60秒的验证码倒计时。当时做的时候把`setState`放在定时器里面执行，

这是因为setState是一个异步操作，并且运行在JavaScript的事件循环系统中。当调用setState时，React并不会立即更新组件的状态，而是将状态更新延迟到下一次事件循环中。如果**组件状态的获取和设置发生在不同的时间点**上，那么就有可能会出现闭包。

解决办法：函数式setState是React中处理异步和并发状 态更新的一种方法。相对于普通的setState，它的语法更加灵活，可以在回调函数中直接获取到最新的state对象，并返回一个新的state对象来进行异步的状态更新。

还有一点就是倒计时的时候每次都要创建新的定时器并且在组件销毁的时候清除定时器，不近很麻烦还浪费性能。所以我就使用了`useRef`钩子，把定时器绑定在了创建创建出来的ref的current对象上面，因为所以在函数组件中，我们会使用 `useRef` 创建 Ref 对象，React 会将 useRef 和函数组件对应的 fiber 对象关联，将 `useRef` 创建的 ref 对象挂载到对应的 fiber 对象上

这样一来每次函数组件执行，只要函数组件不被销毁，那么对应的 fiber 对象实例也会一直存在，所以 ref 也能够被保留下来，这样只用创建一个定时器就可以了。

##### 3. 简历编辑实时预览

​ 简历编辑的实时预览主要分为两个大的模块，一个是简历编辑的模块，一个是简历预览的模块。然后这两个模块包含了很多的子组件，例如简历预览模块就包含个人信息，项目经验，工作经历等等多个组件，简历编辑模块就包含很多`Input`编辑框以及`markdown`编辑区域，简单来说这两个大模块是由被memo包裹的三个公共组件组合而成的，分别是简历预览组件（比如项目经验、工作经历等都是同一个组件）、还有简历编辑的`Input`组件以及`markdown`编辑框组件。尽管已经把组件封装的很原子化了，但是想要实现在输入框编辑简历然后实时在对应的预览区变化还是涉及到编辑组件和简历预览组件之间的通信，然后就用到了`redux/toolkit`，其核心思想就是在组件挂载的时候通过调接口或者本地缓存去获取到到用户的简历信息数据的时候把它存到redux和localStorage中，然后在简历预览模块的组件中使用`useSelector`钩子从redux中去获取对应模块的简历数据然后渲染页面上。在简历编辑输入框中会接受两个props，一个也是通过useSelector去redux中获取对应的用户信息数据（比如用户姓名）然后去设置这个编辑框的标签和默认值，另外一个props是一个用于修改redux中的简历数据的使用usecallback去包裹的dispatch函数，当用户在对应的输入框编辑内容的时候，给输入框绑定一个`onchange`事件，然后在这个事件处理函数中去dispatch对应的action函数去更新redux中的数据。当`redux`中的状态改变的时候，所有依赖redux中数据的组件就会重新从store中获取最新的状态去更新ui界面，实现了在线编辑简历的功能。但此时只是页面状态视觉上的实时编辑，并没有去调接口改变服务端的数据，因为如果在onchange事件中去调接口的话会造成服务端的压力很大，用户编辑的模块是一个抽屉，只有当编辑完成关闭抽屉的时候才会去调接口修改用户的简历信息。但是这样也有不足，就是当用户编辑简历但是没有关闭抽屉的时候遇到一些突发情况比如浏览器突然异常关闭导致没有更新服务端的数据，我的解决方案是在用户编辑的onchange事件中还会执行一个防抖函数，在这个防抖函数中去执行localstorge来缓存用户的简历更新数据。

##### 4.首页图片、路由懒加载

###### 4.1 为什么要使用图片懒加载

为什么要实现图片懒加载？

当首页中图片很大或者数量很多的时候，首页就会加载很慢，会直接影响到用户的体验。

像类似这种图片过多的页面，我们可以通过图片懒加载减轻页面的加载负担。图片懒加载的思路是将页面内的图片未出现在浏览器的可视区域的图片先不做加载，等到图片滚动到浏览器的可视区域后，再去做加载。这样即提高首页加载性能，也提高了用户的体验感。

###### 4.2在React项目中的实现方案

```jsx
import { useRef, useEffect, useState } from "react";
export default function LazyImage({ src, alt }) {
  const ref = useRef(null);
  const [isVisible, setIsVisible] = useState(false);
  useEffect(() => {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        if (entry.isIntersecting) {
          setIsVisible(true);
          observer.unobserve(entry.target);
        }
      });
    });
    observer.observe(ref.current);
    return () => {
      observer.disconnect();
    };
  }, [ref]);
  return <img ref={ref} src={isVisible ? src : ""} alt={alt} />;
}
```

###### 4.3 如何判断元素出现在可视区？

[如何判断元素出现在视口内](https://juejin.cn/post/7194453607108837431#heading-0)

###### 4.4 对ReactSSR的理解？

[看这个博客](http://qwq77.top/2023/05/18/React/%E5%AF%B9ReactSSR%E7%9A%84%E7%90%86%E8%A7%A3/)

##### 5.模板列表使用虚拟列表

[完全掌握分片渲染和虚拟列表](https://juejin.cn/post/7121551701731409934)

[如果后端给你 `1w` 条数据，你如何做展示？](https://juejin.cn/post/7209872710154387517#heading-1)

`虚拟列表`其实是按需显示的一种实现，即只对`可见区域`进行渲染，对`非可见区域`中的数据不渲染或部分渲染的技术，从而达到极高的渲染性能。

假设有1万条记录需要同时渲染，我们屏幕的`可见区域`的高度为`500px`,而列表项的高度为`50px`，则此时我们在屏幕中最多只能看到10个列表项，那么在首次渲染的时候，我们只需加载10条即可。

当滚动发生时，我们可以通过计算当前滚动值得知此时在屏幕`可见区域`应该显示的列表项。

假设滚动发生，滚动条距顶部的位置为`150px`,则我们可得知在`可见区域`内的列表项为`第4项`至`第13项。

首先先计算出由1000个元素撑起的盒子(称之为container)的高度，撑开盒子，让用户能进行滚动操作。

（2）计算出可视区的起始索引、上缓冲区的起始索引以及下缓冲区的结束索引（就像上图滚动后，上缓冲区的起始索引为2，可视区起始索引为4，下缓冲区结束索引为15）。

（3）采用绝对定位，计算上缓冲区到下缓冲区之间的每一个元素在contianer中的top值，只有知道top值才能让元素出现在可视区内。

（4）将上缓冲区到下缓冲区的元素塞到container中。

![](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/39595b1fd7f940f1a3b2a26c301234fe~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

```js
import { useState } from "react";

const FixedSizeList = (props) => {
  const { height, width, itemSize, itemCount, children: Child } = props;
  // 记录滚动掉的高度
  const [scrollOffset, setScrollOffset] = useState(0);

  // 外部容器高度
  const containerStyle = {
    position: "relative",
    width,
    height,
    overflow: "auto",
  };

  // 1000个元素撑起盒子的实际高度
  const contentStyle = {
    height: itemSize * itemCount,
    width: "100%",
  };

  const getCurrentChildren = () => {
    // 可视区起始索引
    const startIndex = Math.floor(scrollOffset / itemSize);
    // 上缓冲区起始索引
    const finialStartIndex = Math.max(0, startIndex - 2);
    // 可视区能展示的元素的最大个数
    const numVisible = Math.ceil(height / itemSize);
    // 下缓冲区结束索引
    const endIndex = Math.min(itemCount - 1, startIndex + numVisible + 2);
    const items = [];
    // 根据上面计算的索引值，不断添加元素给container
    for (let i = finialStartIndex; i < endIndex; i++) {
      const itemStyle = {
        position: "absolute",
        height: itemSize,
        width: "100%",
        // 计算每个元素在container中的top值
        top: itemSize * i,
      };
      items.push(<Child key={i} index={i} style={itemStyle} />);
    }
    return items;
  };

  // 当触发滚动就重新计算
  const scrollHandle = (event) => {
    const { scrollTop } = event.currentTarget;
    setScrollOffset(scrollTop);
  };

  return (
    <div style={containerStyle} onScroll={scrollHandle}>
      <div style={contentStyle}>{getCurrentChildren()}</div>
    </div>
  );
};

export default FixedSizeList;
```

可视区的起始索引为滚动的高度除每个item的高度然后向下取整

上缓冲区的起始索引为0和可视区的起始索引-2然后取最大值

可视区能展示元素的最大个数为content的高度除item的高度向上取整

下缓冲区的结束索引为list的总索引和可视区开始索引加上可视区能展示元素的最大个数+2取最小值

根据上面的索引值，不断添加元素到container

当触发滚动就重新计算

###### 分片渲染

**分片渲染**：简单的说就是一个执行完再执行下一个，其思想是**建立一个队列，通过定时器来进行渲染**，比如说一共有3次，先把这三个放入到数组中，当第一个执行完成后，并剔除执行完成的，在执行第二个，直到全部执行完毕，渲染队列清空。

[高性能渲染十万条数据(时间分片)](https://juejin.cn/post/6844903938894872589)

分页

滚动懒加载

##### 6.同一简历模板不同样式渲染？

在我们的平台上有很多不同样式的简历模板，如果每个模板都写一套组件和样式的代码量会大大增加。

我的解决方案是：用户在挑选简历模板的时候，每个模板都对应一个唯一的`id`，当用户点击对应模板的时候就会传入对应的id并且跳转到指定的路由也就是简历编辑的页面，然后使用`useParams`钩子获取到地址栏的模板id去调接口请求对应的样式，也就是说这个样式代码是放在服务器的，请求回来之后通过`css in js`技术使用`props`传入到对应的样式组件中，然后在样式组件中调用props的回调函数把对应的样式代码渲染到对应的类名中。实现了对简历模板样式的处理。

##### 怎么实现的组件最小原子化渲染？

// 在 React 中，实现组件的最小原子化渲染其实就是尽可能的去封装单一职责并且可复用的小型组件、并且要避免组件不必要的渲染：

// 使用 React.memo：对于函数组件，可以使用 React.memo 高阶组件来包装组件，以进行浅比较并避免不必要的渲染。React.memo 会记住组件的输入，并且当输入不发生变化时，将返回之前渲染的结果。

// 避免在渲染函数中创建新的对象或函数：在组件的渲染函数中创建新的对象或函数会导致每次渲染时都生成新的引用，从而触发不必要的渲染。可以通过将这些对象或函数提升到组件的外部或使用 useMemo 或 useCallback 进行优化，以避免不必要的渲染。

// 使用 key 属性：在使用列表渲染时，为列表项提供稳定的唯一 key 属性。这样，React 可以根据 key 属性来判断哪些列表项发生了变化，并仅对发生变化的列表项进行更新，而不重新渲染整个列表。

​ // 使用 PureComponent 或 shouldComponentUpdate：可以将组件声明为 PureComponent 或手动实现 shouldComponentUpdate 方法。这样，React 在进行渲染之前会对组件的属性和状态进行浅比较，只有当它们发生变化时才会触发重新渲染。这可以避免不必要的渲染。

##### 7.`websocket`，心跳机制，断线重连

###### 7.1什么是websocket

[websocket是什么，特点](https://vue3js.cn/interview/http/WebSocket.html#%E4%B8%80%E3%80%81%E6%98%AF%E4%BB%80%E4%B9%88)

###### 7.2 心跳机制

`websocket`心跳机制：客户端每隔一段时间向服务端发送一个特有的心跳消息，每次服务端收到消息后只需将消息返回，此时，若二者还保持连接，则客户端就会收到消息，若没收到，则说明连接断开，此时，客户端就要主动重连，完成一个周期
心跳的实现也很简单，只需在第一次连接时用回调函数做延时处理，此时还需要设置一个心跳超时时间，若某时间段内客户端发送了消息，而服务端未返回，则认定为断线。

#### 靓点：

0. 首先从商业角度来说的话，我觉得这个项目还是很有市场潜力和发展空间的，因为简历对于任何一个求职者来说都是非常重要的，但是很多人都不知道怎么写简历也不能及时发现简历的问题，在线咨询简历服务师、优化简历等增值服务的需求也很大。

1. 项目代码目录划分清晰，每个组件都实现了数据与`UI`相分离，就是说对数据的请求和处理都不在组件中进行

2. `UI`类似的模块，组件封装的很细致化，逻辑相似的功能也都封装成了相应的自定义hooks

3. 可以通过多种方式登录，比如用户可以通过账号密码+图片验证码登录，也可以使用邮箱+验证码或者手机号+验证码登录

4. 性能优化，`css`工程化，组件用memo包裹，`useSelector`使用`shallowEqual`，当从store中的获取对应的状态没有改变时避免不必要的渲染,使用函数`useCallback`缓存函数，

   4.1 为什么使用`css in js`?
   - 在组件内直接使用`css`该方式编写方便，容易能够根据状态修改样式属性，但是大量的演示编写容易导致代码混乱
   - 组件中引入`.css`文件符合我们日常的编写习惯，但是作用域是全局的，样式之间会层叠
   - 引入`.module.css` 文件能够解决局部作用域问题，但是不方便动态修改样式，需要使用内联的方式进行样式的编写,不能使用连接符(`.xxx-xx`)
   - 通过`css in js `这种方法，可以满足大部分场景的应用，可以类似于预处理器一样样式嵌套、定义、动态修改状态等
   - 大大减少了`css`代码的体积
   - 本质是通过函数的调用，最终创建出一个组件：
     - 这个组件会被自动添加上一个不重复的class

5. 上传模板，让用户上传自己喜欢模板，并且别人使用他的模板他也可以从中获取收益，通过调用后端的接口传入模板的`css`，前端调用接口解析后借用style-components的props展示到对应的模板上--------低代码（不太适合），拖拽`UI`（实现难度大和时间不够）

做、实习项目遇到的难点 如何解决的

项目：首页渲染慢，登录倒计时不对，编辑简历模块、不同模板样式渲染

实习：hooks不能在条件语句中使用，git

### e签宝

#### 1.微前端技改

我们公司有很多管理平台，像文档中心，证据中心，签署中心 、印控中心等等，每个平台都是独立的项目。使用了微前端的技术将所有的平台集合到统一门户，

每个微前端模块可以由不同的团队进行管理，并可以自主选择框架，并且有自己的仓库，可以独立部署上线。但是我们公司的统一门户每次与子应用对接的时候，都要去App.vue里面新增一个主子应用关系的一个映射配置，并且还要去router新增一个路由，还要新建立一个vue文件去使用qiankun.js的语法传入各种配置，为了避免人工操作所带来的繁琐和错误，进行技改。

随着项目的开发，会出现一个前端项目模块巨多的情况，不利于开发和维护。微前端就能帮助我们解决这个问题，帮我们实现了前端复杂项目的解耦，同时能做到跨团队和跨部门协同开发。 对于微前端，它与技术栈无关（主框架不限制介入应用的技术栈，微应用具有完全的自主权），各个微应用间仓库独立，每个微应用之间状态隔离，运行时状态不共享。 常见的微前端实现方案：

- 基于iframe的完全隔离，iframe是浏览器自带的功能，使用简单，隔离完美，不过它无法保持路由状态，页面一刷新状态就丢失，同时iframe中的状态无法突破对应的应用，同时整个应用是全量加载，速度慢。
- 基于single-spa路由劫持的方案。qiankun就是基于这种方案实现的，通过对single-spa做一层封装，根据执行环境的修改，来解析微应用的资源，实现了JS沙箱、样式隔离等特性。
- 借鉴WebComponent思想的micro-app，通过CustomElement结合自定义的ShadowDom，将微前端封装成一个类Web Component组件。

App.vue：通过接口返回的数据，遍历子应用路由自动生成配置

路由：采用正则，子应用以app-开头，以前以前冗余的路由配置，改为app-\*

文件：只保留一个vue文件，通过watch去监听路由的path，动态注册子应用

#### 2.AI电子手绘签名

需求背景是移动端手绘签名需要新增ai手绘的功能，也就是当用户手绘签名完毕后，去调用后端的接口来检测名字书写是否错误，如果某个字错误的话就提示用户重新书写那个字。

首先最主要的两个状态数据就是

当前要手绘的name索引以及name的content，其实就是returnName，是一个数组，每个数组项包括invalid（当前手绘名字是否可用）和drawImg（当前手绘名字的img base64格式）

ai手绘某个字完毕之后：获取当前绘制项文字，将canvas转换为base64格式的图片，将绘制项的图片drawImg设为base64格式，将绘制项的是否已绘制标志设为true，清除绘制面板。然后从头开始找到第一个没有绘制的文字，如果存在，将名称索引设为过滤项的索引，将词汇设为过滤项的内容，如果不存在，则展示提示用户提交签署的文案

指定某个文字手绘：如果该单词已经被手绘过，则不允许被选择。否则则将该单词的下标和内容分别赋值给nameIndex和word变量。

清空手绘resign：首先使用map()方法对this.returnName数组中的每个元素进行操作，并创建一个新的数组。新数组中的每个元素都包含原来元素的所有属性，但其中的drawImg属性被设置为空字符串。然后，该函数将this.nameIndex设置为0，并将this.word设置为this.returnName数组中索引为0的元素的content属性。

手绘完毕后：将returnName作为参数传递给接口调用，该接口返回两个数组：一个是AI手绘检测失败的名字下标数组，另一个是手绘成功的图片base64下标数组。

如果存在手绘失败的字，根据后端返回的失败索引数组，更新returnName的状态，并将nameIndex设置为失败的第一个索引。

如果手绘成功，可以将手绘成功的三个字拼接成一张图片。

### 3.**签署页印章新增置顶和搜索：**

用户签署合同的时候会跳转到签署页，签署页分为两部分，左侧印章列表和右侧签署区，当印章太多的时候用户很难定位到自己想使用的印章，印章类型分为个人印章、企业印章、法人章。每种印章下面也有很多印章。期望是给企业印章能够添加搜索和置顶。但是当时考虑到代码的扩展性，我没有直接去获取企业印章的list数据然后只实现对企业印章搜索和批量置顶功能的实现，而是想实现对（个人印章、企业印章、法人章）通用的搜索、置顶方法，只有当印章类型为企业印章的时候才展示可以搜索、置顶的操作入口。这样如果在以后的迭代中需要新增（个人印章和法人印章的搜索和置顶功能的时候）就很方便。我是在用户进行搜索、置顶操作的时候动态的传入一个当前操作印章列表的类型，然后根据这个类型去接口数据中去找出对应的印章列表数据，然后再去进行搜索和置顶的操作。

置顶的dialog传入的印章列表数据和title也是根据type判断的，

```vue
handleSealTop({ *sealId* = '' }) { *//
如果当前置顶ID在取消置顶ID数组中,从取消数组中删除* if
(*this*.sealCancelTopIdArr.includes(sealId)) { ​ *this*.sealCancelTopIdArr =
*this*.sealCancelTopIdArr.filter(*item* => item !== sealId) ​ *//
如果当前置顶ID在原始置顶ID数组中，加入取消数组* } else if
(*this*.sealOriginalIdTopArr.includes(sealId)) { ​
*this*.sealCancelTopIdArr.push(sealId) ​ *//
如果当前置顶ID已经在本次置顶ID数组中，将它从本次置顶ID数组中删除* } else if
(*this*.sealTopIdArr.includes(sealId)) { ​ *this*.sealTopIdArr =
*this*.sealTopIdArr.filter(*item* => item !== sealId) } else { ​ *//
如果当前置顶ID不在任何数组中，则加入本次置顶ID数组中* ​
*this*.sealTopIdArr.unshift(sealId) } },
```

### 操作系统新增版本定向

需求背景就是指定用户的操作系统去投放不同的广告，

安卓和ios操作系统版本号分别定义两个枚举，利用ts枚举值默认递增的特性，

只用给第一个版本号设定要传给后端的value值，后面的版本号会依次递增，

然后定义一个map来映射要传给后端的枚举值和页面要渲染的标签的

然后定义一个函数借助TS的Record来限制参数类型，返回一个{label:string, value:string}[]的数组用于表单页面渲染

操作系统版本是表单里的一个itme，整个表单是被一个context包裹的，

会给当前表单项注入data和change函数，当表单内数据变化的时候会调用对应的change函数去改变context中当前项data的值

提交表单的时候就会带着所有的表单数据提供给后端

### 微信消息（手写promise.all）

需求背景就是给广告主新增微信消息提醒，用户信息对象包含用户姓名、手机号、新增的微信群名等。但由于后端的设计，提交编辑用户信息时需要调用两个接口：一个是修改微信群名的接口，另一个是用户信息的接口。

为了实现这个需求，可以使用对象的解构语法和 rest 对象，将需要传递给两个接口的参数分开，一个是微信群名，另一个是其他用户个人信息。然后，可以利用 `Promise.all` 来确保在更新用户信息时，只有当两个接口都正确返回时才提示用户更新成功。

在将参数传递给 `Promise.all` 的数组时，可以进行判断，如果微信群名字段没有修改，那么就传入一个已成功的 Promise 和修改用户信息的接口。如果微信群名字段有修改，那么就传入修改微信群名和修改用户信息的两个 Promise。

### 无缝滚动、视差效果

这个需求的背景是要去优化活动页领取记录滚动的组件，这个领取记录就类似pdd的那个，就是一个list列表上面显示这个谁谁谁、什么时间、获得了什么东西。当时旧的列表滚动效果是每隔一段时间列表的数据就会往下移动三个，是使用定时器配合js去更改list的样式去实现的。要改成缓缓向下滚动的一个效果，当时我的实现思路就是利用动画 transform里面的transla te Y配合css的过渡去实现这个效果。但是因为设置的transla te Y的值是list高度的100%，所以滚动到最后的时候也就是list的顶部会滚动到父元素盒子的底部，会出现父元素高度100%的空白。解决方案是给list套一层大小和原本父元素一样的div，当list往下滚动的时候，让这个div同时往上滚动高度100%并且他们滚动结束的时间也是一致的。这样当list滚动结束的时候，list的底部正好是和原本父元素的底部对齐的。

### 统一图片转化逻辑

广告落地页中有很多大小不一的图片，图片的格式就包括像png,jpg,webp等等。但是由于我们业务的特点（做广告投放），有些厂商为了阻止广告投放就会进行一系列的措施，比如禁止掉一些js原生api的使用、其中也对base64格式的图片进行了禁止使用。然后我们开发完成之后在生产环境打包的时候，如果图片大小小于某一个值的时候，vite就会进行一个优化，把这个图片转成base64的格式，但是在开发环境就不会去转化图片，所有有时候就会导致在开发环境图片显示是正确的，但是在生产环境就会出现图片不展示的情况。在vite中我们只能去通过改变配置去更改生产环节打包图片的一些配置，并没有去更改开发环境打包图片的一些配置，所以当时就只能去写一个统一图片转化逻辑插件（插件的本质就是一个函数，返回一个对象，然后在配置项的plugins数组去调用这个函数，vite使用了esbuild和rollup，插件运行的时候就会调用rollup中的很多生命周期，其中有一个就是transform函数，做代码转换的。接受两个参数，一个是文件的类型，一个是文件的路径）去判断当前的环境是开发环境并且是图片的时候，通过node的fs函数去获取文件的信息，如果文件的尺寸大于limit，不用管，小于的话转成base64格式并返回。（返回一个code "export default dataurl"）

### 并发搜索

这个其实就是对一个并发下拉搜索的组件的封装，需求背景就是我需要去做一个运营商数据展示面板的页面，主要分为搜索和展示两个模块，搜索的话就是由很多搜索条件的输入框组成的，分单选和下拉选择，下拉选择的选择项是从后端接口获取的。当时封装这个组件的话主要是分三步，获取数据，展示数据，以及提交搜索关键词调接口去获取指定数据。获取数据的话我是把所有的接口请求路径放到了一个数组里面，然后自定义了一个hooks，首先对这个数组里的所有请求进行一个map遍历去调对应的接口，返回一个promise数组，然后把这个promise数组放到promise.allsetted里面，等所有的结果返回的时候，再把这个数组转成key-value形式的对象，这一步的操作是为了后续使用这个hooks的时候方便解构。（父组件中调用接口），展示数组的话其实就是遍历这个对象传入相应的数据展示select和options组件即可，提交搜索关键词的话就是去调一个回调函数，接受一个搜索类型type和搜索关键词value。当组件选择搜索条件的时候就会增量更新当前的搜索关键词以及对应的value去获取数据。

用过哪些自定义hooks

自定义hooks的应用场景主要就是在不同的组件中复用相同的逻辑，

比如在简历魔法屋那个项目中当用户编辑简历的时候，在编辑项目经历或者工作经历的开始时间结束时间都是dispatch一个修改时间的action和修改之后的起始值，就可以把这些逻辑封装成一个自定义hooks

还有当用户使用手机号登录或者注册都涉及到获取验证码之后的60秒倒计时操作，他们的逻辑都是相似的并且都涉及到了用useRef保存全局唯一的定时器，就可以把这些逻辑封装成一个自定义hooks

实习的时候有一个响应式模型推荐轮播图，涉及到了根据屏幕的宽度不同展示的卡片数量也不同，这个逻辑其实也在很多地方都会用到，我们给这个自定义hooks传入不同的映射值，即不同的屏幕宽度对应的展示列的数量，然后这个自定义hooks也用到了获取屏幕宽度的的自定义hooks

**react和vue区别**

**类组件和函数式组件区别**

**生命周期**

---

你的职业规划是什么/未来3-5年，你有什么打算？

我未来三到五年的规划是在前端方面继续深造。如果我有幸能进入咱们公司的话，我的计划是尽快熟悉咱们公司的项目，并且对项目中自己没有接触过的技术或者是公司内部的技术深入仔细的学习 ，争取早日能为公司做一些贡献，然后我希望能够提高一下自己的业务能力争取早日能够在项目中担任主要开发者角色，我也希望能够提高一下自己的沟通能力和团队协作能力，为咱们团队的发展贡献自己的力量。并且会坚持撰写技术博客，总结自己平时的经验。我也会持续学习前端领域的最新技术和趋向，可以是在某一个领域深入研究也可以是扩展自己的知识面，因为我目前做的项目和实习项目其实都是PC端的，像前端还有很多领域我都还没深入了解，比如跨端，小程序，3D等等，其实我这边都是比较感兴趣的，但是具体需要学习哪些领域还是要看公司的具体需求。

你的优点是什么？

抗压能力强，技术面广，项目经验多，有相关的实习经验，学习能力强，有良好的学习习惯

8、你的缺点是什么？

因为我是农村出来的，所以我觉得我可能没有大城市孩子的那么勇敢自信，那么善于去表现自己。

有时候太偏执

9、你的兴趣爱好是什么？

听音乐，看古诗词，学习新技术

平时怎么学习前端

大二开始初学前端的时候主要是通过网上的视频课程学习，遇到不懂得也会通过w3c，mdn,菜鸟教程等等去查阅资料，当时也加入了我们学院一个专门学习前端的部门，主要也是学习和实践前端基础知识，做一些小demo之类的。然后也会通过做项目来提高自己的前端开发能力，刚开始主要就是跟着网上的视频，或者githup上的项目等去实践。后来是自己一个人独立开发一个前端项目，在开发项目的时候也学习了很多知识点，提高了自己的开发能力。平时也会关注一些技术文章，像掘金，githup，或者是抖音，b站一些短视频技术分析，我自己也会总结学习经验，知识点等撰写博客，自己学习前端也写了很多的笔记。大三的话也花了点钱进入了一个编程社区，和里面的小伙伴一起分享技术，遇到不会的问题也可以问里面的大佬。然后就是通过实习。

你为啥是个破二本

首先不可否认三年前我和985确实有差距，但是我觉得三年足够改变一个人。而且教育背景只能说明他们能获得更好的学习资源和学习环境，并不能完全决定一个人的能力和潜力。虽然我在二本学校学习，但我有很强的自主学习能力。我有自己的学习计划和方法，这使我能够在短时间内掌握大量知识。我在大学期间积极参与各种项目和实习，积累了丰富的实践经验。解决实际问题的能力和沟通能力

13、你手上还有其它的offer吗？

​ 有一些实习的offer，校招的话有上家实习公司的offer，但是我还是特别喜欢咱们公司的，因为别的offer都是城市不是很喜欢

最值得你骄傲的一件事

从我大一到大四过往经历以来，最值得我骄傲的一件事

既不是我身边的同学朋友眼中的自己平时在自学前端的过程中自己的专业课排名也比较靠前也没有挂科记录，或者是大二四六级一遍过，又或者是计算机竞赛获得奖项什么的。我觉得最值得我骄傲的一件事就是我做任何事之前都提前规划好并且会一直坚持下去，我从大二就开始学习前端，其实这两年走来受过很多影响，比如我们老师就劝过我学习后端，网上也有很多散播焦虑的文章帖子，而且这两年行情也不是很好，但是这些都没有让我动摇，并且把这一件事一直坚持到了现在，而且在这途中我能明显感觉到通过这两年的坚持也养成了好的学习习惯，学习能力也有了很大的提高，我觉得这件事才是最值得我骄傲的。

为什么实习离职了？

因为我从一开始学前端就打算去杭州发展，我很喜欢杭州这座城市并且杭州的互联网氛围很好，而且生活压力也比北京小很多，我有很多同学朋友亲戚也都在杭州那边。

并且一开始去北京实习就是想着为秋招做准备，因为有个实习经历秋招的时候肯定机会更多一点。

1.自我介绍

2.dom树的渲染

3.css会阻塞dom树的渲染吗？为什么？

4.js会阻塞dom的渲染吗，async和defer的区别

5.css会阻塞js渲染吗

6.说说跨页面通信

7.同源下你会使用哪些跨页面通信

8.浏览器存储？说说indexDb？同源哪些存储可用？

9.cookie和session的区别

10.css in js和css module\LESS\SASS的区别

11.antd5和antd4的区别

12.你的global css怎么覆盖antd的css in js样式？

13.js的异步方案有哪些？

14.说说promise的原理？

15.promise为啥知道成功了？

16.说说react 常见的hooks

17.useMemo和useCallback区别，项目中怎么用的

18.封装公用组件的方法

19.antd 怎么封装公用组件的？哪些参数必传哪些不必

20.React16和18的区别

21.react中用过哪些数据流

22.useContext和Redux对比props有什么优势

23.webpack有了解吗

24.写过自定义plugin和loader吗

--下面都是个人项目的问题--

25.项目的登录逻辑咋写的?登录鉴权、jwt

26.用户token过期了你怎么检测

27.无感刷新token的原理

28.简历实时编辑怎么实现的？每次编辑都要调接口吗？

29.用户的简历数据你是保存在内存中,当出现浏览器刷新\异常关闭你怎么保存用户已经修改的数据

30.遇到用户的简历数据量太多你怎么处理

32.了解我们公司吗？

33.反问

1.自我介绍

2.问了一下计算机设计大赛和蓝桥杯的奖项是干嘛的

3.css in js的优缺点，怎么和sass/less进行舍取

4.实习：AI生成队列的优化？你怎么想到这个优化方案的

5.怎么学习前端的？在githup上面学什么？

6.介绍项目的核心模块、功能

7.跟面试官小姐姐聊天

8.websocket和http的区别?在cookie使用方面有什么区别

9.为什么要用websocket

10.跨域解决方案？cors客户端还是服务端解决

11.虚拟dom，react怎么对虚拟dom进行优化

12.React portals

13.对jsx的理解

14.高阶组件的使用场景/原理

15.React router原理

16.单页面和之前的ajax页面区别

17.Redux的三大特性？对action的理解

18.平时项目开发怎么优化？比如白屏卡顿等等

19.TS的泛型使用场景

20.最近在学什么？怎么用AI学习的

21.反问，后续流程，需要提前实习吗？

### 简历魔法屋：

##### newfeat

- 首页动画
- 简历编辑新手引导
- 简历编辑可拖动排序
- 简历编辑可更改主题色,字体样式大小等
- 简历编辑可关闭模块
- 可以上传头像
- json导出

##### bug

- 模板key 相同 --
- 聊天没有情况输入框--
- 点击简历模块自动定位到对应的编辑模块
- 简历服务位置不对--

  1.js事件循环（八股吟唱）
  2.dom渲染在事件循环的哪个阶段（深入一点我直接g）❌ 3.虚拟dom（八股吟唱）4.为什么js操作虚拟dom要比浏览器操作真实dom要快？（ok深入一点我又g）❌
  5.ReactDOM渲染器是如何工作的。（说出来一点点）
  6.React 的异步渲染和并发模式（就说了state批处理。。）❌ 7.（实习经历一顿拷打。。。。）❌ 8.闲聊（顺带拷打。。说到喜欢看github，让我说一个看过比较了解的开源源码，。。。）❌ 9.手撕：给你一个function，接收一个root（二叉树根节点），m(二叉树的深度)和n，要求反转二叉树深度n以下的节点（根本不会做。。）❌ 10.手写一个usecallback。。（这里面试官提示好几次要用到useEffect和useRef，根本不会。。）❌

一：提前确定好对的方向、把握信息差

一定要提前准备，提前确定好对的方向（有些专业的某些方向真的超级卷），最好在大一大二的时候多尝试一下不同的方向，然后选择一个自己喜欢的并且适合自己的岗位方向然后再去不断努力。不得不承认运气 > 选择 > 努力。另外信息差真的太太太重要了，特别是对于没人带并且学校学习氛围环境也不好的，建议可以多关注各种学习平台（牛客、掘金、B站等等）了解目前的行情和风向、也可以认识别的小伙伴一起同步学习资源和信息差。注意不要被培训班和卖课的忽悠了！！

二：好的学习习惯与学习能力

一定要坚持每天学习，培养一个良好的学习喜欢和强大的学习能力。我觉得很多二本的学生在这个方面和92差距很大，其实不管我们学会了多少知识或者技术或者拿过什么奖项做过多少项目，从某种意义上来说但凡只要肯付出努力和时间其实都可以做得到，但是有一个好的习惯和学习能力会让我们以后不管碰到什么技术和业务都能快速上手，这才是我们应该具备的东西

三：基础和算法

基础肯定是必不可少的，建议学习这块的时候不用着急慢慢理解，基础扎实后面学什么都很快。在校期间可以和小伙伴或者学长一起参加竞赛。如果想进大厂的话算法也是必不可少的，否则就算简历筛选通过了，笔试和面试也会手撕算法的。

四：项目和实习

项目经验一定不要千篇一律！！（比如清一色的购物商城、外卖、管理系统、音乐APP这种）可能一千份简历里面990个都是类似的技能+项目。前面提到的这些项目只能用于学习，建议可以和现实或者网上的小伙伴一起合作开发有新意有重难点的项目。双非的话实习也非常重要，建议在大二暑期就去日常实习、大三暑期很多公司就开始大规模招聘暑期可转正的实习生、随后便是大四的秋招和春招。如果能暑期实习直接转正那再好不过了，在秋春招之前领先别人两段实习经验也是非常加分的。实习如果一开始进不了大厂可以先从小公司跳起、然后利用小公司的实习经验再跳到中大厂的实习，不要在意实习赚不到钱还白白打工，能学到东西和混到经验才是最重要的。

五：自信乐观 & 保持好心态

这个过程肯定是漫长又曲折的、一定要保持良好的心态。面试的时候一定要自信从容（面想去的公司之前可以先投不想去的小公司面试增加面试经验或者让小伙伴模拟面试自己）、面试过程中不仅专业知识要强悍，个人品质&沟通&表达问题和解决问题的能力也是筛选人的重要条件。在实习工作涉及到团队协作的过程中一定不要太内向或者只会闷头干活，遇到问题要大胆勇敢的去请教，可以适当的表现自己、和同事领导处好关系、让自己在团队中有一定的影响力

PS：上述经验是总结了其他优秀的小伙伴、我实习过程中的同事和领导、面试过程中的面试官共同的建议。

抖音账号运营: 主导网易平顶山分公司抖音账号的运营工作。深入研究抖音平台运营规则和用户需求，制定有效的运营策略，成功吸引了大量用户的关注和互动。
市场调查与内容策划: 负责了平顶山地区的市场调查，通过数据分析，了解当地市场的竞争态势和用户喜好。基于调研结果，策划抖音账号的内容，确保内容贴近当地文化，满足用户需求。
视频制作与发布: 独立负责抖音账号的视频拍摄、剪辑和发布工作。运用专业技能，制作出高质量的视频内容，并根据平台规则和用户习惯，选择合适的时间发布，提升了视频的曝光度和点击率。

负责本校所有艺术实践课程，担任班长协助教师教学工作；维护课堂纪律，管理签到签退，确保课程参与度。
策划并执行校庆活动，包括场地布置与人员安排；打造具有艺术与文化特色的校庆盛宴。
多次负责学校大型活动艺术面对面、非遗进校园等活动的管理，确保活动现场的秩序与安全问题，有效应对突发事件。

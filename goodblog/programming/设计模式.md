---
title: 深入理解设计模式：TypeScript实现经典设计模式的完整指南
slug: design-patterns-typescript-guide
published: true
featured: true
category: 前端
publishedAt: 2025-06-15T00:00:00.000Z
readingTime: 11
---

## 1. 背景与引言

设计模式是软件工程中解决常见设计问题的可复用方案，它们代表了最佳实践，是经过时间验证的解决特定问题的方法。在现代Web开发中，合理运用设计模式能够让代码更加模块化、可维护和可扩展。

### 1.1.1. 为什么设计模式很重要？

在复杂的前端应用开发中，我们经常面临以下挑战：

- **代码耦合度高**：组件间相互依赖，难以独立测试和修改
- **功能扩展困难**：新需求导致大量代码修改
- **代码重复**：相似功能在不同地方重复实现
- **维护成本高**：代码结构混乱，bug修复困难

设计模式提供了应对这些挑战的标准化解决方案，帮助开发者写出更优雅、更易维护的代码。

## 2. 核心概念与分类

### 1.2.1. 设计模式的三大类型

设计模式通常分为三大类：

1. **创建型模式**：关注对象的创建过程
   - 单例模式、工厂模式、建造者模式等

2. **结构型模式**：关注对象间的组合关系
   - 装饰器模式、适配器模式、代理模式等

3. **行为型模式**：关注对象间的通信和职责分配
   - 观察者模式、策略模式、命令模式等

### 1.2.2. SOLID原则基础

在学习设计模式前，了解SOLID原则很重要：

- **S** - 单一职责原则
- **O** - 开闭原则
- **L** - 里氏替换原则
- **I** - 接口隔离原则
- **D** - 依赖倒置原则

## 3. 经典设计模式的TypeScript实现

### 1.3.1. 发布订阅模式（Publisher-Subscriber Pattern）

发布订阅模式是前端开发中最常用的模式之一，它实现了对象间的松耦合通信。

#### 1.3.1.1. 基础实现

```typescript
type EventHandler = (...args: any[]) => void;

interface IEventEmitter {
  on(eventName: string, handler: EventHandler): void;
  off(eventName: string, handler: EventHandler): void;
  emit(eventName: string, ...args: any[]): void;
  once(eventName: string, handler: EventHandler): void;
}

class EventEmitter implements IEventEmitter {
  private events: Record<string, EventHandler[]> = {};

  /**
   * 订阅事件
   * @param eventName 事件名称
   * @param handler 事件处理函数
   */
  on(eventName: string, handler: EventHandler): void {
    if (!this.events[eventName]) {
      this.events[eventName] = [];
    }
    this.events[eventName].push(handler);
  }

  /**
   * 取消订阅
   * @param eventName 事件名称
   * @param handler 要移除的处理函数
   */
  off(eventName: string, handler: EventHandler): void {
    const handlers = this.events[eventName];
    if (handlers) {
      this.events[eventName] = handlers.filter((h) => h !== handler);
      // 如果没有处理函数了，删除该事件
      if (this.events[eventName].length === 0) {
        delete this.events[eventName];
      }
    }
  }

  /**
   * 发布事件
   * @param eventName 事件名称
   * @param args 传递给处理函数的参数
   */
  emit(eventName: string, ...args: any[]): void {
    const handlers = this.events[eventName];
    if (handlers) {
      // 创建副本防止在执行过程中handlers被修改
      [...handlers].forEach((handler) => {
        try {
          handler(...args);
        } catch (error) {
          console.error(`Event handler error for ${eventName}:`, error);
        }
      });
    }
  }

  /**
   * 一次性订阅
   * @param eventName 事件名称
   * @param handler 事件处理函数
   */
  once(eventName: string, handler: EventHandler): void {
    const onceHandler = (...args: any[]) => {
      handler(...args);
      this.off(eventName, onceHandler);
    };
    this.on(eventName, onceHandler);
  }

  /**
   * 获取所有事件名称
   */
  getEventNames(): string[] {
    return Object.keys(this.events);
  }

  /**
   * 清除所有事件监听器
   */
  clear(): void {
    this.events = {};
  }
}
```

#### 1.3.1.2. 实际应用场景

```typescript
// 用户状态管理示例
interface User {
  id: string;
  name: string;
  avatar?: string;
}

class UserService extends EventEmitter {
  private currentUser: User | null = null;

  async login(credentials: {
    username: string;
    password: string;
  }): Promise<User> {
    try {
      // 模拟登录API调用
      const user = await this.authenticateUser(credentials);
      this.currentUser = user;

      // 发布登录成功事件
      this.emit("user:login", user);
      this.emit("user:change", user);

      return user;
    } catch (error) {
      this.emit("user:loginError", error);
      throw error;
    }
  }

  logout(): void {
    const user = this.currentUser;
    this.currentUser = null;
    this.emit("user:logout", user);
    this.emit("user:change", null);
  }

  private async authenticateUser(credentials: any): Promise<User> {
    // 模拟API调用
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          id: "1",
          name: credentials.username,
          avatar: "https://example.com/avatar.jpg",
        });
      }, 1000);
    });
  }
}

// 使用示例
const userService = new UserService();

// 订阅用户状态变化
userService.on("user:login", (user: User) => {
  console.log(`欢迎 ${user.name}！`);
  // 更新UI状态
});

userService.on("user:logout", () => {
  console.log("用户已退出");
  // 清理用户数据
});

userService.on("user:change", (user: User | null) => {
  // 通知所有组件更新用户状态
  updateGlobalUserState(user);
});

function updateGlobalUserState(user: User | null) {
  // 实际的状态更新逻辑
  console.log("Global user state updated:", user);
}
```

### 1.3.2. 单例模式（Singleton Pattern）

单例模式确保一个类只有一个实例，常用于全局状态管理、配置管理等场景。

#### 1.3.2.1. 线程安全的单例实现

```typescript
class ConfigManager {
  private static instance: ConfigManager;
  private config: Record<string, any> = {};
  private isInitialized = false;

  private constructor() {
    // 私有构造函数防止外部实例化
  }

  static getInstance(): ConfigManager {
    if (!ConfigManager.instance) {
      ConfigManager.instance = new ConfigManager();
    }
    return ConfigManager.instance;
  }

  async initialize(): Promise<void> {
    if (this.isInitialized) return;

    try {
      // 模拟从服务器加载配置
      this.config = await this.loadConfigFromServer();
      this.isInitialized = true;
      console.log("Configuration loaded successfully");
    } catch (error) {
      console.error("Failed to load configuration:", error);
      throw error;
    }
  }

  get<T>(key: string, defaultValue?: T): T {
    if (!this.isInitialized) {
      throw new Error(
        "ConfigManager not initialized. Call initialize() first."
      );
    }
    return this.config[key] ?? defaultValue;
  }

  set(key: string, value: any): void {
    this.config[key] = value;
  }

  getAll(): Record<string, any> {
    return { ...this.config };
  }

  private async loadConfigFromServer(): Promise<Record<string, any>> {
    // 模拟API调用
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          apiBaseUrl: "https://api.example.com",
          timeout: 5000,
          retryAttempts: 3,
          enableAnalytics: true,
        });
      }, 500);
    });
  }
}

// 使用示例
async function initializeApp() {
  const config = ConfigManager.getInstance();
  await config.initialize();

  const apiUrl = config.get<string>("apiBaseUrl");
  const timeout = config.get<number>("timeout", 3000);

  console.log(`API URL: ${apiUrl}, Timeout: ${timeout}ms`);
}
```

### 1.3.3. 工厂模式（Factory Pattern）

工厂模式将对象创建逻辑封装起来，客户端无需知道具体的创建细节。

#### 1.3.3.1. 抽象工厂模式实现

```typescript
// 产品接口
interface Button {
  render(): string;
  onClick(): void;
}

interface Dialog {
  render(): string;
  show(): void;
}

// 具体产品实现
class WindowsButton implements Button {
  render(): string {
    return '<button class="windows-btn">Windows Button</button>';
  }

  onClick(): void {
    console.log("Windows button clicked");
  }
}

class MacButton implements Button {
  render(): string {
    return '<button class="mac-btn">Mac Button</button>';
  }

  onClick(): void {
    console.log("Mac button clicked");
  }
}

class WindowsDialog implements Dialog {
  render(): string {
    return '<div class="windows-dialog">Windows Dialog</div>';
  }

  show(): void {
    console.log("Showing Windows dialog");
  }
}

class MacDialog implements Dialog {
  render(): string {
    return '<div class="mac-dialog">Mac Dialog</div>';
  }

  show(): void {
    console.log("Showing Mac dialog");
  }
}

// 抽象工厂
abstract class UIFactory {
  abstract createButton(): Button;
  abstract createDialog(): Dialog;
}

// 具体工厂
class WindowsUIFactory extends UIFactory {
  createButton(): Button {
    return new WindowsButton();
  }

  createDialog(): Dialog {
    return new WindowsDialog();
  }
}

class MacUIFactory extends UIFactory {
  createButton(): Button {
    return new MacButton();
  }

  createDialog(): Dialog {
    return new MacDialog();
  }
}

// 工厂选择器
class UIFactorySelector {
  static createFactory(platform: "windows" | "mac"): UIFactory {
    switch (platform) {
      case "windows":
        return new WindowsUIFactory();
      case "mac":
        return new MacUIFactory();
      default:
        throw new Error(`Unsupported platform: ${platform}`);
    }
  }
}

// 使用示例

function createUI(platform: "windows" | "mac") {
  const factory = UIFactorySelector.createFactory(platform);
  const button = factory.createButton();
  const dialog = factory.createDialog();

  console.log(button.render());
  console.log(dialog.render());

  button.onClick();
  dialog.show();
}

// 根据用户系统自动选择
const userPlatform = navigator.platform.toLowerCase().includes("mac")
  ? "mac"
  : "windows";
createUI(userPlatform);
```

### 1.3.4. 策略模式（Strategy Pattern）

策略模式定义了一系列算法，使它们可以相互替换，让算法的变化独立于使用算法的客户端。

#### 1.3.4.1. 支付策略实现

```typescript
// 策略接口
interface PaymentStrategy {
  processPayment(amount: number, currency: string): Promise<PaymentResult>;
  validatePayment(amount: number): boolean;
}

// 支付结果接口
interface PaymentResult {
  success: boolean;
  transactionId?: string;
  message: string;
}

// 具体策略实现
class CreditCardStrategy implements PaymentStrategy {
  constructor(
    private cardNumber: string,
    private cvv: string,
    private expiryDate: string
  ) {}

  validatePayment(amount: number): boolean {
    return amount > 0 && amount <= 10000 && this.isValidCard();
  }

  async processPayment(
    amount: number,
    currency: string
  ): Promise<PaymentResult> {
    if (!this.validatePayment(amount)) {
      return {
        success: false,
        message: "Invalid payment amount or card details",
      };
    }

    // 模拟信用卡支付处理
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          success: true,
          transactionId: `CC_${Date.now()}`,
          message: `Successfully charged ${amount} ${currency} to credit card ending in ${this.cardNumber.slice(-4)}`,
        });
      }, 1500);
    });
  }

  private isValidCard(): boolean {
    // 简单的卡号验证（实际应用中需要更复杂的验证）
    return this.cardNumber.length >= 16 && this.cvv.length >= 3;
  }
}

class PayPalStrategy implements PaymentStrategy {
  constructor(
    private email: string,
    private password: string
  ) {}

  validatePayment(amount: number): boolean {
    return amount > 0 && this.isValidCredentials();
  }

  async processPayment(
    amount: number,
    currency: string
  ): Promise<PaymentResult> {
    if (!this.validatePayment(amount)) {
      return {
        success: false,
        message: "Invalid payment amount or PayPal credentials",
      };
    }

    // 模拟PayPal支付处理
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          success: true,
          transactionId: `PP_${Date.now()}`,
          message: `Successfully processed ${amount} ${currency} via PayPal (${this.email})`,
        });
      }, 1000);
    });
  }

  private isValidCredentials(): boolean {
    return this.email.includes("@") && this.password.length >= 6;
  }
}

class CryptoStrategy implements PaymentStrategy {
  constructor(
    private walletAddress: string,

    private cryptoType: "BTC" | "ETH"
  ) {}

  validatePayment(amount: number): boolean {
    return amount > 0 && this.isValidWallet();
  }

  async processPayment(
    amount: number,
    currency: string
  ): Promise<PaymentResult> {
    if (!this.validatePayment(amount)) {
      return {
        success: false,
        message: "Invalid payment amount or wallet address",
      };
    }

    // 模拟加密货币支付处理
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          success: true,
          transactionId: `${this.cryptoType}_${Date.now()}`,
          message: `Successfully processed ${amount} ${currency} via ${this.cryptoType} wallet ${this.walletAddress.slice(0, 8)}...`,
        });
      }, 2000);
    });
  }

  private isValidWallet(): boolean {
    return this.walletAddress.length >= 26;
  }
}

// 支付上下文
class PaymentProcessor {
  private strategy: PaymentStrategy;

  constructor(strategy: PaymentStrategy) {
    this.strategy = strategy;
  }

  setStrategy(strategy: PaymentStrategy): void {
    this.strategy = strategy;
  }

  async executePayment(
    amount: number,
    currency: string = "USD"
  ): Promise<PaymentResult> {
    console.log(`Processing payment of ${amount} ${currency}...`);

    try {
      const result = await this.strategy.processPayment(amount, currency);
      console.log(result.message);
      return result;
    } catch (error) {
      console.error("Payment processing failed:", error);
      return {
        success: false,
        message: "Payment processing failed due to system error",
      };
    }
  }
}

// 使用示例
async function demonstratePaymentStrategies() {
  const processor = new PaymentProcessor(
    new CreditCardStrategy("1234567812345678", "123", "12/25")
  );

  // 信用卡支付
  let result = await processor.executePayment(100);
  console.log("Credit Card Result:", result);

  // 切换到PayPal支付
  processor.setStrategy(new PayPalStrategy("user@example.com", "password123"));
  result = await processor.executePayment(50);
  console.log("PayPal Result:", result);

  // 切换到加密货币支付
  processor.setStrategy(
    new CryptoStrategy("1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa", "BTC")
  );
  result = await processor.executePayment(0.001);
  console.log("Crypto Result:", result);
}
```

### 1.3.5. 装饰器模式（Decorator Pattern）

装饰器模式允许在不修改原对象的情况下，动态地添加新功能。

#### 1.3.5.1. TypeScript装饰器实现

```typescript
// 方法装饰器：性能监控
function performanceMonitor(
  target: any,
  propertyKey: string,
  descriptor: PropertyDescriptor
) {
  const originalMethod = descriptor.value;

  descriptor.value = function (...args: any[]) {
    const startTime = performance.now();
    console.log(`🚀 开始执行 ${propertyKey} 方法`);

    const result = originalMethod.apply(this, args);

    // 处理异步方法
    if (result instanceof Promise) {
      return result
        .then((data) => {
          const endTime = performance.now();
          console.log(
            `✅ ${propertyKey} 方法执行完成，耗时: ${(endTime - startTime).toFixed(2)}ms`
          );
          return data;
        })
        .catch((error) => {
          const endTime = performance.now();
          console.log(
            `❌ ${propertyKey} 方法执行失败，耗时: ${(endTime - startTime).toFixed(2)}ms`
          );
          throw error;
        });
    } else {
      const endTime = performance.now();
      console.log(
        `✅ ${propertyKey} 方法执行完成，耗时: ${(endTime - startTime).toFixed(2)}ms`
      );
      return result;
    }
  };

  return descriptor;
}

// 方法装饰器：缓存
function cache(maxAge: number = 60000) {
  // 默认1分钟缓存
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;
    const cacheMap = new Map<string, { value: any; timestamp: number }>();

    descriptor.value = function (...args: any[]) {
      const cacheKey = JSON.stringify(args);
      const cached = cacheMap.get(cacheKey);
      const now = Date.now();

      // 检查缓存是否有效
      if (cached && now - cached.timestamp < maxAge) {
        console.log(`📦 从缓存获取 ${propertyKey} 的结果`);
        return cached.value;
      }

      const result = originalMethod.apply(this, args);

      // 处理异步方法
      if (result instanceof Promise) {
        return result.then((data) => {
          cacheMap.set(cacheKey, { value: data, timestamp: now });
          console.log(`💾 缓存 ${propertyKey} 的结果`);
          return data;
        });
      } else {
        cacheMap.set(cacheKey, { value: result, timestamp: now });
        console.log(`💾 缓存 ${propertyKey} 的结果`);
        return result;
      }
    };

    return descriptor;
  };
}

// 方法装饰器：重试机制
function retry(maxAttempts: number = 3, delay: number = 1000) {
  return function (
    target: any,
    propertyKey: string,
    descriptor: PropertyDescriptor
  ) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      let lastError: Error;

      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          console.log(`🔄 ${propertyKey} 第 ${attempt} 次尝试`);
          const result = await originalMethod.apply(this, args);

          if (attempt > 1) {
            console.log(`✅ ${propertyKey} 在第 ${attempt} 次尝试后成功`);
          }

          return result;
        } catch (error) {
          lastError = error as Error;
          console.log(`❌ ${propertyKey} 第 ${attempt} 次尝试失败: ${error}`);

          if (attempt < maxAttempts) {
            console.log(`⏳ ${delay}ms 后重试...`);
            await new Promise((resolve) => setTimeout(resolve, delay));
          }
        }
      }

      console.log(`💥 ${propertyKey} 在 ${maxAttempts} 次尝试后仍然失败`);
      throw lastError;
    };

    return descriptor;
  };
}

// 应用装饰器的服务类
class DataService {
  @performanceMonitor
  @cache(30000) // 30秒缓存
  async fetchUserData(userId: string): Promise<any> {
    // 模拟API调用
    console.log(`🌐 正在从服务器获取用户 ${userId} 的数据...`);

    return new Promise((resolve) => {
      setTimeout(() => {
        resolve({
          id: userId,
          name: `User ${userId}`,
          email: `user${userId}@example.com`,
          lastLogin: new Date().toISOString(),
        });
      }, 1000);
    });
  }

  @performanceMonitor
  @retry(3, 500)
  async uploadFile(file: File): Promise<string> {
    console.log(`📤 正在上传文件: ${file.name}`);

    // 模拟不稳定的网络连接
    if (Math.random() < 0.6) {
      throw new Error("网络连接不稳定");
    }

    return new Promise((resolve) => {
      setTimeout(() => {
        resolve(`upload_${Date.now()}_${file.name}`);
      }, 800);
    });
  }

  @performanceMonitor
  calculateComplexData(input: number[]): number {
    console.log(`🧮 正在计算复杂数据，输入长度: ${input.length}`);

    // 模拟复杂计算
    let result = 0;
    for (let i = 0; i < input.length; i++) {
      for (let j = 0; j < 1000; j++) {
        result += Math.sqrt(input[i] * j);
      }
    }

    return result;
  }
}

// 使用示例
async function demonstrateDecorators() {
  const dataService = new DataService();

  console.log("=== 测试缓存装饰器 ===");
  await dataService.fetchUserData("123");
  await dataService.fetchUserData("123"); // 这次会从缓存获取

  console.log("\n=== 测试重试装饰器 ===");
  const fakeFile = new File(["test content"], "test.txt", {
    type: "text/plain",
  });
  try {
    await dataService.uploadFile(fakeFile);
  } catch (error) {
    console.log("上传最终失败");
  }

  console.log("\n=== 测试性能监控装饰器 ===");
  const testData = Array.from({ length: 1000 }, (_, i) => i);
  dataService.calculateComplexData(testData);
}
```

## 4. 最佳实践与注意事项

### 1.4.1. 设计模式选择指南

1. **发布订阅模式**
   - ✅ 适用场景：组件间通信、状态管理、事件系统
   - ⚠️ 注意事项：避免过度使用导致调试困难，及时清理监听器防止内存泄漏

2. **单例模式**
   - ✅ 适用场景：全局配置、缓存管理、日志服务
   - ⚠️ 注意事项：谨慎使用，可能导致全局状态问题和测试困难

3. **工厂模式**
   - ✅ 适用场景：复杂对象创建、多平台兼容、依赖注入
   - ⚠️ 注意事项：避免过度抽象，保持代码的可读性

4. **策略模式**
   - ✅ 适用场景：算法选择、支付方式、数据处理策略
   - ⚠️ 注意事项：确保策略接口设计合理，避免策略爆炸

5. **装饰器模式**
   - ✅ 适用场景：功能增强、AOP编程、权限控制
   - ⚠️ 注意事项：注意执行顺序，避免装饰器链过长

### 1.4.2. 性能优化建议

```typescript
// 1. 事件监听器管理
class OptimizedEventEmitter extends EventEmitter {
  private maxListeners = 10;

  on(eventName: string, handler: EventHandler): void {
    super.on(eventName, handler);

    const handlers = this.events[eventName];
    if (handlers && handlers.length > this.maxListeners) {
      console.warn(
        `Event ${eventName} has ${handlers.length} listeners, consider optimizing`
      );
    }
  }

  // 批量移除监听器
  removeAllListeners(eventName?: string): void {
    if (eventName) {
      delete this.events[eventName];
    } else {
      this.events = {};
    }
  }
}

// 2. 缓存策略优化
class LRUCache<K, V> {
  private cache = new Map<K, V>();
  private maxSize: number;

  constructor(maxSize: number = 100) {
    this.maxSize = maxSize;
  }

  get(key: K): V | undefined {
    const value = this.cache.get(key);
    if (value !== undefined) {
      // 移到最新位置
      this.cache.delete(key);
      this.cache.set(key, value);
    }
    return value;
  }

  set(key: K, value: V): void {
    if (this.cache.has(key)) {
      this.cache.delete(key);
    } else if (this.cache.size >= this.maxSize) {
      // 删除最久未使用的项
      const firstKey = this.cache.keys().next().value;
      this.cache.delete(firstKey);
    }

    this.cache.set(key, value);
  }
}
```

### 1.4.3. 常见陷阱与解决方案

1. **内存泄漏问题**

```typescript
// ❌ 错误示例：忘记清理监听器
class Component {
  constructor() {
    globalEventBus.on("data-update", this.handleUpdate);
  }

  handleUpdate = (data: any) => {
    // 处理更新
  };

  // 组件销毁时忘记清理
}

// ✅ 正确示例：及时清理
class Component {
  constructor() {
    globalEventBus.on("data-update", this.handleUpdate);
  }

  handleUpdate = (data: any) => {
    // 处理更新
  };

  destroy() {
    globalEventBus.off("data-update", this.handleUpdate);
  }
}
```

2. **过度设计问题**

```typescript
// ❌ 过度抽象
interface Shape {
  draw(): void;
}

class ShapeFactory {
  createShape(type: string): Shape {
    // 为简单形状创建复杂工厂
  }
}

// ✅ 适度抽象
class Rectangle {
  draw(): void {
    console.log("Drawing rectangle");
  }
}

class Circle {
  draw(): void {
    console.log("Drawing circle");
  }
}
```

## 5. 实际项目应用案例

### 1.5.1. 状态管理系统

```typescript
// 基于设计模式的轻量级状态管理
class StateManager extends EventEmitter {
  private state: Record<string, any> = {};
  private middleware: Array<(action: Action, state: any) => void> = [];

  // 策略模式：不同的状态更新策略
  private updateStrategies = {
    merge: (state: any, payload: any) => ({ ...state, ...payload }),
    replace: (state: any, payload: any) => payload,
    append: (state: any, payload: any) => [...state, ...payload],
  };

  dispatch(action: Action): void {
    // 中间件处理
    this.middleware.forEach((mw) => mw(action, this.state));

    const strategy = this.updateStrategies[action.strategy || "merge"];

    const oldState = { ...this.state };

    this.state = strategy(this.state, action.payload);

    // 发布状态变化
    this.emit("state:change", {
      action,
      oldState,
      newState: this.state,
    });
  }

  getState(): any {
    return { ...this.state };
  }

  // 装饰器模式：添加中间件
  addMiddleware(middleware: (action: Action, state: any) => void): void {
    this.middleware.push(middleware);
  }
}

interface Action {
  type: string;
  payload: any;

  strategy?: "merge" | "replace" | "append";
}

// 使用示例
const stateManager = new StateManager();

// 添加日志中间件
stateManager.addMiddleware((action, state) => {
  console.log(`Action: ${action.type}`, { action, state });
});

// 监听状态变化
stateManager.on("state:change", ({ action, oldState, newState }) => {
  console.log("State changed:", { action: action.type, oldState, newState });
});

// 分发动作
stateManager.dispatch({
  type: "SET_USER",
  payload: { id: 1, name: "John" },
  strategy: "merge",
});
```

## 6. 总结与扩展

### 1.6.1. 关键要点回顾

1. **设计模式不是银弹**：合理选择，避免过度设计
2. **TypeScript增强**：利用类型系统提高代码安全性
3. **性能考虑**：注意内存使用和执行效率
4. **测试友好**：设计时考虑可测试性
5. **团队协作**：统一模式使用规范

### 1.6.2. 进阶学习方向

1. **更多设计模式**：代理模式、适配器模式、建造者模式等
2. **架构模式**：MVC、MVP、MVVM、DDD等
3. **函数式编程模式**：函子、单子、柯里化等
4. **响应式编程**：RxJS、状态流管理等

### 1.6.3. 推荐资源

- **经典书籍**：《设计模式：可复用面向对象软件的基础》
- **现代实践**：《JavaScript设计模式与开发实践》
- **TypeScript官方文档**：装饰器、高级类型使用
- **开源项目**：学习优秀开源项目中的模式应用

通过系统学习和实践这些设计模式，你将能够编写出更加优雅、可维护和可扩展的TypeScript代码。记住，设计模式是工具，关键在于在合适的场景下使用合适的模式。

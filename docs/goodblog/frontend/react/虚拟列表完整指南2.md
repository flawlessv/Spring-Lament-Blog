---
title: TanStack Virtual 源码解析：定高/不定高虚拟列表实现原理以及框架无关设计
slug: tanstack-virtual-source-code-analysis123
published: true
featured: true
publishedAt: 2025-12-02
readingTime: 20
category: 前端
tags:
  - 源码解析
coverImage: https://haowallpaper.com/link/common/file/previewFileImg/15691093812220224
---

> 深入 TanStack Virtual 源码，理解虚拟列表的核心原理与框架无关设计

## 什么是虚拟列表

当列表项达到数千甚至数万条时，全部渲染会导致页面卡顿、内存占用过高。**虚拟列表**只渲染可视区域及附近的元素，实现高性能的大数据列表展示。

假设有1万条数据，可视区域高度`500px`，每项高度`50px`，那么可视区域最多显示10项。虚拟列表只渲染这10条，而不是全部1万条。

![虚拟列表示意图](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e15195cf16a558~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

| 对比项       | 传统渲染           | 虚拟列表                  |
| ------------ | ------------------ | ------------------------- |
| DOM节点数    | 全部渲染（10000+） | 只渲染可见部分（10-20个） |
| 首屏渲染时间 | 数秒甚至更长       | 几乎瞬间完成              |
| 内存占用     | 随数据量线性增长   | 保持恒定                  |
| 滚动性能     | 卡顿明显           | 流畅丝滑                  |

## 实现思路

虚拟列表的核心是**动态计算可视区域内应该显示哪些列表项**：

1. 计算可视区域的**起始索引**（`startIndex`）
2. 计算可视区域的**结束索引**（`endIndex`）
3. 截取对应的数据进行渲染
4. 计算**偏移量**（`startOffset`）让渲染内容对齐可视区域

![虚拟列表实现原理](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/10/29/16e1519a393dee2c~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.awebp)

## 固定高度虚拟列表

### HTML 结构

虚拟列表需要三层结构：

```tsx
<div className="container" style={{ height: 500, overflow: "auto" }}>
  {/* 占位层：撑开滚动条 */}
  <div style={{ height: totalHeight }} />

  {/* 渲染层：实际渲染的列表项 */}
  <div style={{ transform: `translateY(${startOffset}px)` }}>
    {visibleData.map((item) => (
      <div key={item.id}>{item.content}</div>
    ))}
  </div>
</div>
```

- **占位层**：高度等于所有列表项的总高度，用于形成正常的滚动条
- **渲染层**：通过 `transform` 偏移到正确位置

### 核心公式

```typescript
// 列表总高度
const listHeight = listData.length * itemSize;

// 可视区域能显示的项数
const visibleCount = Math.ceil(screenHeight / itemSize);

// 起始索引（Math.floor 确保不遗漏部分可见项）
const startIndex = Math.floor(scrollTop / itemSize);

// 结束索引
const endIndex = startIndex + visibleCount;

// 偏移量
const startOffset = scrollTop - (scrollTop % itemSize);
```

**为什么用 Math.floor？** 当 `scrollTop = 120px`，`itemSize = 50px` 时：

- `Math.floor(120/50) = 2`：第2项部分可见，需要渲染
- `Math.ceil(120/50) = 3`：会遗漏第2项，导致空白

### 完整实现

```tsx
import React, { useState, useMemo } from "react";

const VirtualList = ({ listData, itemSize, containerHeight }) => {
  const [scrollTop, setScrollTop] = useState(0);

  const visibleCount = Math.ceil(containerHeight / itemSize);
  const listHeight = listData.length * itemSize;
  const startIndex = Math.floor(scrollTop / itemSize);
  const endIndex = Math.min(startIndex + visibleCount, listData.length);
  const visibleData = listData.slice(startIndex, endIndex);
  const startOffset = scrollTop - (scrollTop % itemSize);

  return (
    <div
      style={{
        height: containerHeight,
        overflow: "auto",
        position: "relative",
      }}
      onScroll={(e) => setScrollTop(e.currentTarget.scrollTop)}
    >
      <div style={{ height: listHeight }} />
      <div
        style={{
          position: "absolute",
          top: 0,
          transform: `translateY(${startOffset}px)`,
        }}
      >
        {visibleData.map((item, i) => (
          <div key={startIndex + i} style={{ height: itemSize }}>
            {item.content}
          </div>
        ))}
      </div>
    </div>
  );
};
```

## 动态高度虚拟列表

动态高度是虚拟列表最具挑战性的场景。TanStack Virtual 采用**估算 + 测量 + 增量更新**的策略。

### 四阶段流程

```
【阶段一：初始估算】
用 estimateSize 计算所有元素位置，快速显示页面
    ↓
【阶段二：实际测量】
元素渲染后，ResizeObserver 获取真实高度
    ↓
【阶段三：增量更新】
发现实际高度 ≠ 估算高度，更新缓存
如果元素在可视区域上方，补偿滚动位置
    ↓
【阶段四：重计算】
只重新计算变化部分之后的元素
```

### 阶段一：初始估算

在元素渲染前，用预估高度初始化位置信息：

```typescript
interface PositionItem {
  index: number;
  height: number;
  top: number;
  bottom: number;
}

// 用预估高度初始化
const positions = listData.map((_, index) => ({
  index,
  height: estimatedItemSize, // 预估值，如 80px
  top: index * estimatedItemSize,
  bottom: (index + 1) * estimatedItemSize,
}));

// 列表总高度 = 1000 × 80 = 80,000px
```

**估算值越准确，后续调整越少，性能越好。**

### 阶段二：实际测量

元素渲染后，通过 `ResizeObserver` 获取真实高度：

```typescript
const resizeObserver = new ResizeObserver((entries) => {
  entries.forEach((entry) => {
    const index = Number(entry.target.getAttribute("data-index"));
    const newHeight =
      entry.borderBoxSize?.[0]?.blockSize ?? entry.contentRect.height;
    updateItemHeight(index, newHeight);
  });
});

// 观察元素
resizeObserver.observe(element);
```

**为什么用 ResizeObserver 而不是 getBoundingClientRect？**

| 对比项   | getBoundingClientRect | ResizeObserver                |
| -------- | --------------------- | ----------------------------- |
| 触发时机 | 需要手动调用          | 自动监听，尺寸变化时触发      |
| 持续监听 | ❌ 只测量一次         | ✅ 图片加载、内容变化都能响应 |
| 性能     | 可能触发重排          | 异步回调，性能更好            |

### 阶段三：滚动位置补偿（关键！）

这是动态高度最精妙的设计。考虑以下场景：

1. 用户正在看索引 100-110 的内容，`scrollTop = 5000px`
2. 索引 50 的图片加载完成，高度从 100px 变为 200px

**如果不做处理：**

```
索引 50 高度 +100px → 索引 51-110 位置全部下移 100px → 用户看到的内容"跳"了一下！
```

**解决方案：**

```typescript
const updateItemHeight = (index: number, newHeight: number) => {
  const delta = newHeight - positions[index].height;

  if (delta !== 0) {
    // 关键：如果变化的元素在当前滚动位置上方，补偿滚动位置
    if (positions[index].top < scrollTop) {
      containerRef.current.scrollTop += delta; // 同步调整滚动位置
    }

    // 更新位置信息...
  }
};
```

**效果：** 滚动位置也 +100px，用户看到的内容相对位置不变，感知不到变化！

### 阶段四：增量更新

只重新计算变化位置之后的元素：

```typescript
// 假设索引 5000 的元素高度变化
// 只重新计算后面 5000 项，前面的直接复用
for (let i = 5000; i < 10000; i++) {
  positions[i].top = positions[i - 1].bottom;
  positions[i].bottom = positions[i].top + positions[i].height;
}
```

**变化位置越靠后，性能提升越明显！**

### 二分查找起始索引

动态高度无法用除法计算索引，需要查找第一个 `bottom > scrollTop` 的项：

```typescript
const binarySearch = (scrollTop: number): number => {
  let start = 0,
    end = positions.length - 1,
    result = 0;

  while (start <= end) {
    const mid = Math.floor((start + end) / 2);
    if (positions[mid].bottom > scrollTop) {
      result = mid;
      end = mid - 1;
    } else {
      start = mid + 1;
    }
  }
  return result;
};
```

### 缓冲区（overscan）

快速滚动时可能出现白屏，解决方案是在可视区域上下额外渲染一些元素：

```
┌─────────────────────────┐
│     overscan (5 项)     │  ← 缓冲区上方
├─────────────────────────┤
│   可视区域 (10 项)      │  ← 用户看到的部分
├─────────────────────────┤
│     overscan (5 项)     │  ← 缓冲区下方
└─────────────────────────┘
```

```typescript
const actualStartIndex = Math.max(0, startIndex - overscan);
const actualEndIndex = Math.min(listData.length, endIndex + overscan);
```

**overscan 建议值：3-5**，平衡性能和体验。

### 完整实现

```tsx
import React, { useState, useEffect, useRef, useCallback } from "react";

const DynamicVirtualList = ({
  listData,
  estimatedItemSize,
  containerHeight,
  overscan = 5,
}) => {
  const [scrollTop, setScrollTop] = useState(0);
  const [listHeight, setListHeight] = useState(0);
  const [, forceUpdate] = useState({});

  const containerRef = useRef(null);
  const positionsRef = useRef([]);
  const scrollTopRef = useRef(0);
  const resizeObserverRef = useRef(null);
  const elementsCache = useRef(new Map());

  // 初始化 positions
  useEffect(() => {
    positionsRef.current = listData.map((_, i) => ({
      index: i,
      height: estimatedItemSize,
      top: i * estimatedItemSize,
      bottom: (i + 1) * estimatedItemSize,
    }));
    setListHeight(listData.length * estimatedItemSize);
  }, [listData, estimatedItemSize]);

  // 更新高度（带滚动补偿）
  const updateItemHeight = useCallback((index, newHeight) => {
    const positions = positionsRef.current;
    if (!positions[index]) return;

    const delta = newHeight - positions[index].height;
    if (Math.abs(delta) < 0.5) return;

    // 滚动位置补偿
    if (positions[index].top < scrollTopRef.current && containerRef.current) {
      containerRef.current.scrollTop += delta;
    }

    // 更新当前项
    positions[index].height = newHeight;
    positions[index].bottom = positions[index].top + newHeight;

    // 增量更新后续项
    for (let k = index + 1; k < positions.length; k++) {
      positions[k].top = positions[k - 1].bottom;
      positions[k].bottom = positions[k].top + positions[k].height;
    }

    setListHeight(positions[positions.length - 1]?.bottom || 0);
    forceUpdate({});
  }, []);

  // 初始化 ResizeObserver
  useEffect(() => {
    resizeObserverRef.current = new ResizeObserver((entries) => {
      entries.forEach((entry) => {
        const index = Number(entry.target.getAttribute("data-index"));
        if (!isNaN(index)) {
          const height =
            entry.borderBoxSize?.[0]?.blockSize ?? entry.contentRect.height;
          updateItemHeight(index, height);
        }
      });
    });
    return () => resizeObserverRef.current?.disconnect();
  }, [updateItemHeight]);

  // 测量元素
  const measureElement = useCallback((node, index) => {
    if (!node) {
      const cached = elementsCache.current.get(index);
      if (cached) {
        resizeObserverRef.current?.unobserve(cached);
        elementsCache.current.delete(index);
      }
      return;
    }
    if (elementsCache.current.get(index) === node) return;
    elementsCache.current.set(index, node);
    resizeObserverRef.current?.observe(node);
  }, []);

  // 二分查找
  const binarySearch = (scrollTop) => {
    const positions = positionsRef.current;
    let start = 0,
      end = positions.length - 1,
      result = 0;
    while (start <= end) {
      const mid = Math.floor((start + end) / 2);
      if (positions[mid].bottom > scrollTop) {
        result = mid;
        end = mid - 1;
      } else {
        start = mid + 1;
      }
    }
    return result;
  };

  const visibleCount = Math.ceil(containerHeight / estimatedItemSize) + 1;
  const startIndex = binarySearch(scrollTop);
  const actualStartIndex = Math.max(0, startIndex - overscan);
  const endIndex = Math.min(
    startIndex + visibleCount + overscan,
    listData.length
  );
  const visibleData = listData.slice(actualStartIndex, endIndex);
  const startOffset = positionsRef.current[actualStartIndex]?.top ?? 0;

  return (
    <div
      ref={containerRef}
      style={{
        height: containerHeight,
        overflow: "auto",
        position: "relative",
      }}
      onScroll={(e) => {
        scrollTopRef.current = e.currentTarget.scrollTop;
        setScrollTop(e.currentTarget.scrollTop);
      }}
    >
      <div style={{ height: listHeight }} />
      <div
        style={{
          position: "absolute",
          top: 0,
          transform: `translateY(${startOffset}px)`,
        }}
      >
        {visibleData.map((item, idx) => {
          const actualIndex = actualStartIndex + idx;
          return (
            <div
              key={item.id ?? actualIndex}
              data-index={actualIndex}
              ref={(el) => measureElement(el, actualIndex)}
            >
              {item.content}
            </div>
          );
        })}
      </div>
    </div>
  );
};
```

## 框架无关的设计理念

TanStack Virtual 最强大的特性是**框架无关**：一套核心代码，支持 React、Vue、Angular、Solid 等所有主流框架。

### 为什么要框架无关

虚拟列表的核心逻辑与框架无关：

- 滚动位置计算
- 可见区域判断
- 元素位置计算
- 尺寸测量与缓存

这些只依赖浏览器原生 API（ResizeObserver、scroll 事件）和纯 JavaScript 数据结构。

**框架无关的好处：**

- 核心逻辑只维护一份，Bug 修复一次所有框架受益
- 适配新框架只需 ~50 行代码
- 核心层可独立测试，无需框架环境

### 架构分层

```
┌─────────────────────────────────────────────────────────────┐
│                    框架适配层（薄层）                        │
│         react-virtual / vue-virtual / ...                   │
│  职责：对接框架的响应式系统，触发组件重新渲染               │
└─────────────────────────────────────────────────────────────┘
                              ↓ 调用
┌─────────────────────────────────────────────────────────────┐
│                 核心层（virtual-core）                       │
│  职责：虚拟列表的所有业务逻辑                               │
│  - 位置计算、尺寸测量、缓存管理、滚动控制                   │
└─────────────────────────────────────────────────────────────┘
                              ↓ 使用
┌─────────────────────────────────────────────────────────────┐
│                    浏览器原生 API                            │
│  ResizeObserver / scroll 事件 / offsetHeight / scrollTop   │
└─────────────────────────────────────────────────────────────┘
```

核心层完全不依赖任何框架，`virtual-core` 的 `package.json` 中 `dependencies` 为空！

### React 适配实现

React 适配层的核心是：**在核心层状态变化时触发组件重渲染**。

```typescript
function useVirtualizerBase(options) {
  // 强制重渲染的技巧
  const rerender = React.useReducer(() => ({}), {})[1];

  const resolvedOptions = {
    ...options,
    onChange: (instance, sync) => {
      // 核心层调用这个回调时，触发 React 重渲染
      if (sync) {
        flushSync(rerender); // 同步更新（滚动时）
      } else {
        rerender(); // 异步更新（尺寸变化）
      }
    },
  };

  // 创建核心实例（只创建一次）
  const [instance] = React.useState(() => new Virtualizer(resolvedOptions));

  // 每次渲染都更新 options
  instance.setOptions(resolvedOptions);

  // 生命周期管理
  useIsomorphicLayoutEffect(() => {
    return instance._didMount();
  }, []);

  return instance;
}

export function useVirtualizer(options) {
  return useVirtualizerBase({
    observeElementRect: observeElementRect,
    observeElementOffset: observeElementOffset,
    scrollToFn: elementScroll,
    ...options,
  });
}
```

**关键点：**

- `useReducer(() => ({}), {})[1]`：每次调用返回新对象，触发 React 更新
- `flushSync`：滚动时需要同步更新，避免闪烁
- `useIsomorphicLayoutEffect`：兼容 SSR

### Vue 适配实现

Vue 适配层使用 `shallowRef` 和 `triggerRef`：

```typescript
function useVirtualizerBase(options) {
  const virtualizer = new Virtualizer(unref(options));
  const state = shallowRef(virtualizer); // 浅响应式引用

  const cleanup = virtualizer._didMount();

  watch(
    () => unref(options),
    (options) => {
      virtualizer.setOptions({
        ...options,
        onChange: (instance, sync) => {
          triggerRef(state); // 手动触发 Vue 响应式更新
        },
      });
      virtualizer._willUpdate();
      triggerRef(state);
    },
    { immediate: true }
  );

  onScopeDispose(cleanup);
  return state;
}
```

**关键点：**

- `shallowRef`：只追踪引用变化，不深度追踪内部属性，性能更好
- `triggerRef`：虽然对象引用未变，但手动触发更新
- `unref`：解包响应式对象，传递纯 JavaScript 对象给核心层

### 数据流示意

```
用户滚动
    ↓
浏览器 scroll 事件
    ↓
核心层：更新 scrollOffset，计算新的可见范围
    ↓
核心层：调用 this.options.onChange(this, true)
    ↓
框架适配层：
  - React: flushSync(rerender)
  - Vue: triggerRef(state)
    ↓
组件重新渲染
    ↓
UI 更新
```

**核心层完全不知道自己运行在哪个框架中**，它只负责计算和调用 `onChange` 回调。

## 总结

### 核心要点

1. **固定高度**：数学公式直接计算，`Math.floor` 确保不遗漏部分可见项
2. **动态高度**：估算 → 测量 → 增量更新 → 滚动补偿
3. **缓冲区（overscan）**：上下额外渲染几项，解决快速滚动白屏
4. **框架无关**：核心逻辑与 UI 框架解耦，适配层只负责触发重渲染

### 参考资源

- [TanStack Virtual 官方文档](https://tanstack.com/virtual)
- [TanStack Virtual GitHub](https://github.com/tanstack/virtual)
- [ResizeObserver MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/ResizeObserver)

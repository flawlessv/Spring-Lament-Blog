# 深入理解 Event Loop 原理

## 一、进程与线程的区别

在了解 Event Loop 之前,我们需要先理解进程和线程的概念:

- **进程 (Process)**: 是操作系统进行资源分配和调度的基本单位,每个进程都有独立的内存空间
- **线程 (Thread)**: 是进程内的执行单元,一个进程可以包含多个线程,它们共享进程的内存空间
- **关系**: 进程好比工厂,线程好比工厂中的工人,多个工人(线程)协同完成工厂(进程)的任务

## 二、为什么 JavaScript 是单线程

> JavaScript 在设计之初是作为浏览器脚本语言,主要用于与用户进行页面交互和操纵 DOM。为避免由不可预测的用户操作可能带来的复杂的并发问题,JavaScript 被设计成单线程的,这也是这门语言的核心特征之一。

JavaScript 引擎之所以是单线程,主要有以下几个原因:

1. **避免 DOM 操作冲突**: 如果多个线程同时操作 DOM,可能会出现竞态条件和数据不一致的问题。假设线程 A 要删除某个 DOM 节点,而线程 B 要修改这个节点的样式,那么就会产生冲突
2. **简化编程模型**: 单线程避免了复杂的锁机制和线程同步问题
3. **历史设计**: JavaScript 最初只是一个简单的脚本语言,单线程足以满足当时的需求

## 三、浏览器的多进程架构

现代浏览器是一个多进程多线程的应用程序,内部工作极其复杂,其程度直逼操作系统。它拥有数个功能模块,为避免单个模块崩溃牵连其他模块,导致连锁反应使浏览器彻底崩溃,浏览器在启动时会开启多个进程,把不同的功能模块放在不同的进程里。

![浏览器多进程架构](https://youke1.picui.cn/s1/2025/11/05/690b0f7acd95a.png)

浏览器进程众多,其中比较重要的有:

### 1. 浏览器进程

浏览器进程是浏览器的主进程,**无论打开多少浏览器窗口,它仅有一个**。

它主要负责:

- 浏览器界面显示(导航栏、书签栏、刷新按钮等)
- 用户交互处理
- 各子进程管理

> 注意: 这里说的界面和交互,不是视窗内的网站界面,而是指浏览器本身自带的部分。刚打开浏览器的时候只有一个浏览器进程,其他进程都是它创建的。

### 2. 网络进程

网络进程主要负责处理网站的数据请求和响应,通常情况下,它与渲染进程的交互最为密切。

工作流程:

1. 渲染进程需要请求资源时,将任务交给网络进程处理
2. 网络进程取得响应结果后返回给渲染进程
3. 网络进程内部开启多个线程,实现多网络请求的异步化处理

### 3. 渲染进程

渲染进程负责控制和显示视窗部分(网站页面)的所有内容,主要工作包括:

- 解析 HTML、CSS
- 生成渲染树
- 执行布局和绘制
- 执行 JavaScript 代码

**关键特性**:

- 在现代浏览器中,**默认会为每个标签页创建一个渲染进程**
- 出于安全考虑,渲染进程运行在沙箱模式下,无法访问系统资源

### 浏览器多进程的优势

相比于单进程浏览器，多进程有如下优点：

- 避免单个page crash影响整个浏览器
- 避免第三方插件crash影响整个浏览器
- 多进程充分利用多核优势
- 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性
  简单点理解：如果浏览器是单进程，那么某个Tab页崩溃了，就影响了整个浏览器，体验有多差；同理如果是单进程，插件崩溃了也会影响整个浏览器；而且多进程还有其它的诸多优势。。。

## 四、渲染进程的线程组成

虽然 JavaScript 是单线程的,但浏览器是多线程的。渲染进程内包含多个线程:

![渲染线程架构](https://youke1.picui.cn/s1/2025/11/05/690b0f7bace08.png)

### 1. GUI 渲染线程

- 负责渲染浏览器界面,解析 HTML、CSS
- 构建 DOM 树和渲染树
- 进行布局和绘制
- **与 JS 引擎线程互斥**: 当 JS 引擎执行时,GUI 线程会被挂起,GUI 更新会被保存在队列中等待 JS 引擎空闲时立即执行

### 2. JS 引擎线程

- 也叫 JS 内核,负责解析执行 JavaScript 脚本程序的主线程(例如 V8 引擎)
- 一直等待着任务队列中任务的到来,然后加以处理
- **一个 Tab 页(渲染进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序**

### 3. 事件触发线程

- 属于浏览器内核线程,主要用于控制事件循环
- 当 JS 引擎执行代码块如 `setTimeout` 时(也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等)
- 会将对应任务添加到事件触发线程中
- 当对应的事件符合触发条件被触发时,该线程会把事件添加到待处理队列的队尾,等待 JS 引擎的处理

### 4. 定时器触发线程

- 主要控制 `setInterval` 和 `setTimeout`
- 浏览器定时计数器并不是由 JavaScript 引擎计数的,因为 JavaScript 引擎是单线程的,如果处于阻塞线程状态就会影响记计时的准确性
- 当计时完毕后,会把定时器的处理函数推进事件队列中,等待 JS 引擎线程执行

### 5. 异步 HTTP 请求线程

- 在 XMLHttpRequest 连接后通过浏览器新开的一个线程请求
- 检测到状态变更时,如果设置有回调函数,该线程会把回调函数推进事件队列中,等待 JS 引擎线程执行

## 五、渲染主线程与事件循环

渲染进程启动后,会开启一个**渲染主线程**,它是浏览器中最繁忙的线程,需要处理的任务包括但不限于:

- 解析 HTML、CSS
- 计算样式、布局
- 处理图层、绘制页面
- 执行 JavaScript 代码
- 执行各种回调函数

### 消息队列机制

渲染主线程一个线程要处理好这么多任务,那如何进行任务调度便成了重点,而**浏览器采用的则是排队机制**。

浏览器会提供一个**先进先出的消息队列**(也称任务队列),用于存储待执行的任务:

1. 渲染主线程不断依次从消息队列中取出任务执行
2. 遇到异步操作则交给其他线程处理
3. 异步操作完成后,响应结果再次加入消息队列
4. 等待渲染主线程拿取执行

如此,所有的任务都能有条不紊地进行,而**这个过程便是事件循环(Event Loop)**(也称消息循环)。

### 多队列优先级

任务在消息队列里先进先出并没有优先级,但**浏览器中消息队列不止一条,它们是有优先级的**。

过去我们把消息队列分为**宏队列**和**微队列**:

- **宏队列**: 排队宏任务(DOM 操作回调、定时器回调、UI 绘制等)
- **微队列**: 排队微任务(Promise 回调等)
- 渲染主线程的每次循环会**优先执行并清空微队列任务**,再执行宏队列

不过随着时间推移,浏览器复杂度急剧提升,仅两个队列已经不能满足现代浏览器的需求了。于是,**W3C 在制定 HTML 规范的时候已抛弃宏队列的说法**。

### 现代浏览器的队列实现

各浏览器厂商在实现事件循环时会根据最新的 W3C 规范:

> 每个任务都有其任务类型,同一个类型的任务必须在同一个队列里排队。在一次事件循环中,浏览器可根据实际情况从不同的队列中取出任务执行。并且浏览器必须准备好一个微队列,其中的任务优先于所有其他队列的任务执行。

不同浏览器,除微队列外,队列的种类和数量均可能不同,这取决于浏览器厂商。

**在目前的 Chrome 实现中,至少包含了下面几个队列**:

1. **微队列**: 用于存放需要最快执行的任务,优先级极高,将任务加入微队列的方式有 `Promise.then()`、`MutationObserver`
2. **交互队列**: 用于存放用户操作后产生的事件处理任务,优先级次于微队列
3. **延迟队列**: 用于存放定时器到达后的回调任务,优先级次于交互队列

> ⚠️ **特别注意**: 人工合成的事件派发,即直接写在代码里的 `dom.click()` 或 `dispatchEvent()`,相对于浏览器而言并不是真正的用户交互,会被当作同步任务执行。只有用户动作触发的事件,才会作为异步任务,在事件循环中等待执行。

**参考链接**: [MDN - EventTarget.dispatchEvent()](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent)

## 六、事件循环的工作原理

### 事件循环机制概述

JavaScript 是单线程语言，为了处理异步操作，采用了事件循环机制。事件循环会不断地从任务队列中取出任务执行，直至所有任务执行完毕。其运行步骤大致如下：

1. **从堆栈中取出待执行的任务并执行**：执行当前宏任务（Task）中的同步代码，直到调用栈为空
2. **检查微任务队列**：如果有任务，则依次执行微任务队列中的所有任务，直至队列为空。执行过程中如果产生新的微任务，追加到队尾，继续执行直到队列清空
3. **浏览器判断是否需要渲染**：满足屏幕刷新率（如 60Hz 对应 16.6ms 间隔）、有 DOM 变更、页面处于前台等条件，才会执行渲染
4. **检查是否有宏任务需要执行**：如果有，则从优先级最高的宏任务队列中取出一个执行，执行完成后回到步骤 2，否则继续等待新的宏任务到达

### 什么是事件循环

单线程意味着 JavaScript 引擎在同一时间只能做一件事情,即同步地执行代码。但在代码执行过程中不可避免地会遇到一些无法立即执行的任务,例如:

- 计时器到达时间后要执行的任务 → `setInterval`、`setTimeout`
- 网络请求完成后要执行的任务 → `XMLHttpRequest`、`Fetch`
- 监听到用户操作后要执行的任务 → `addEventListener`

如果让执行 JavaScript 的线程去处理这些任务,就会导致该线程处于长期阻塞的状态,而宿主环境中的 JavaScript 执行线程往往还承担着极其重要的工作。例如,在浏览器中,如果执行 JavaScript 的线程长期阻塞,就会导致浏览器卡死!

为避免上述情况发生,**JavaScript 的宿主环境使用了异步的方式来处理这种无法立即执行的任务**。

当遇到异步任务时:

1. 宿主环境会将其交给其他线程处理
2. 执行 JavaScript 的线程则会立即结束当前任务
3. 转而去执行后续代码

### 事件循环流程图

![事件循环流程](https://youke1.picui.cn/s1/2025/11/05/690b0f7c25a07.png)

**事件循环的基本流程**:

1. 同步任务和异步任务分别进入不同的执行"场所",同步的进入主线程,异步的进入 Event Table 并注册函数
2. 当指定的事情完成时,Event Table 会将这个函数移入 Event Queue
3. 主线程内的任务执行完毕为空,会去 Event Queue 读取对应的函数,进入主线程执行
4. 上述过程会不断重复,也就是常说的 **Event Loop(事件循环)**

### 主线程如何知道执行栈为空

从谷歌浏览器源码来看,渲染进程进入渲染流程,渲染主线程便会开启一个**无限循环**。

每次循环都会检查消息队列中是否有任务:

- **如果有**: 就拿出队列中的第一个任务执行,执行过程中若遇到异步操作,渲染主线程会将其加入其他线程的任务队列进行处理,它自己则不会等待,转而去执行后续代码
- **如果没有**: 则进入休眠状态

当其他线程把异步任务处理完成,就会将后续的回调操作包装成新任务,加入消息队列末尾,等待渲染主线程拿取执行。

其他所有线程,包括其他进程的线程,都可以往消息队列末尾添加任务。当新任务添加时如果主线程处于休眠状态,则会将其唤醒以继续循环拿取任务执行。

### 事件循环的执行顺序

**事件循环的顺序,决定了 JavaScript 代码的执行顺序**。事件循环的执行流程一般是：

1. **先执行同步代码**（这本身属于第一个宏任务）
2. **检查微任务队列**：若队列不为空，取出队首任务执行，执行过程中如果产生新的微任务，追加到队尾，继续执行直到队列清空
3. **浏览器视情况决定是否进行 UI 渲染**（详见下方"浏览器 UI 渲染时机"小节）
4. **从宏任务队列中取出一个任务执行**：执行完后，再次清空微任务队列，如此循环往复

进入整体代码(宏任务)后,开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始,找到其中一个任务队列执行完毕,再执行所有的微任务。

![事件循环关系图](https://youke1.picui.cn/s1/2025/11/05/690b0f7bec01d.png)

#### 示例代码分析

```javascript
setTimeout(function () {
  console.log("setTimeout");
});

new Promise(function (resolve) {
  console.log("promise");
  resolve();
}).then(function () {
  console.log("then");
});

console.log("console");
```

**执行流程分析**:

1. 这段代码作为宏任务,进入主线程
2. 先遇到 `setTimeout`,将其回调函数注册后分发到宏任务 Event Queue
3. 接下来遇到了 `Promise`,`new Promise` **立即执行**,输出 `'promise'`,`then` 函数分发到微任务 Event Queue
4. 遇到 `console.log()`,立即执行,输出 `'console'`
5. 第一个宏任务执行结束,检查微任务队列,发现 `then` 在微任务 Event Queue 里面,执行,输出 `'then'`
6. 第一轮事件循环结束,开始第二轮循环,从宏任务 Event Queue 开始,发现 `setTimeout` 对应的回调函数,立即执行,输出 `'setTimeout'`
7. 结束

**输出结果**: `promise` → `console` → `then` → `setTimeout`

### 浏览器 UI 渲染时机

浏览器决定是否进行 UI 渲染的情况主要与以下因素相关：

1. **屏幕刷新率**：浏览器通常会根据屏幕的刷新率来决定是否进行 UI 渲染。例如，对于 60Hz 刷新率的屏幕，其理想状态是每 16.6ms（1000ms/60）渲染一帧。如果距离上次渲染未超过 16.6ms，浏览器可能会选择不进行渲染，以避免资源浪费和不必要的性能消耗。只有当距离上次渲染超过了这个时间间隔，浏览器才会执行渲染流程，以保证页面的流畅性。

2. **JS 执行与任务队列**：JavaScript 执行会暂停渲染，直到当前 JS 任务完成。在事件循环中，每次执行完宏任务且微任务队列为空时，浏览器会检查是否需要渲染。如果此时有 DOM 或样式的更改，且距离上次渲染时间合适，浏览器就会进行 UI 渲染。但如果微任务队列中还有任务，即使有渲染需求，也会先执行微任务，从而推迟渲染。

3. **页面状态与用户交互**：如果页面处于不可见状态，如在后台标签页，浏览器可能会降低渲染频率，甚至降低到 4FPS 左右甚至更低。另外，当用户进行了一些会触发页面更新的交互操作，如滚动页面、点击按钮等，浏览器会根据具体情况判断是否需要立即进行 UI 渲染，以响应用户操作。

4. **强制布局与重绘**：当 JavaScript 代码修改了元素的大小、位置或样式等会影响布局的属性时，可能会触发强制布局。此时，尽管调用堆栈不为空，浏览器也会暂停主线程 JavaScript 的执行而去渲染页面，以确保页面显示的正确性。

## 七、宏任务与微任务

### 术语说明：规范层面 vs 开发者社区

> ⚠️ **重要说明**：关于"宏任务"和"微任务"术语的理解

你的理解非常准确，这其实是规范层面定义和开发者社区约定的区别，核心结论如下：

- **ECMAScript 规范 + V8 引擎层面**：没有 "宏任务 / 微任务" 的术语，而是以 **任务队列（Task Queue）+ 优先级** 来定义异步任务的执行逻辑
- **浏览器 / Node.js 实践 + 开发者社区**："宏任务 / 微任务" 的说法仍在广泛使用，本质是对不同优先级任务队列的简化抽象

#### 一、V8 与规范的真实逻辑：任务队列 + 优先级

ECMAScript 规范里只定义了 **Job**（对应微任务）和 **宿主环境的 Task**（对应宏任务）两个大类，而 V8 引擎在实现时，会对任务进行更细粒度的优先级划分，不同优先级的任务队列会按顺序被事件循环消费。

**核心任务分类（规范术语）**：

- **Task（任务）**：由宿主环境发起（浏览器 / Node.js），比如 `setTimeout`、I/O、UI事件、script整体代码
  - 特点：不同类型的 Task 有不同的队列，事件循环一次只从一个队列取一个任务执行，执行完后会先清空微任务队列，再考虑渲染或取下一个 Task

- **Job（作业）**：由 JS 引擎发起，属于 "高优先级异步任务"，比如 `Promise.then`、`queueMicrotask`
  - 特点：所有 Job 会进入一个统一的微任务队列，在当前 Task 执行完毕后立即全部执行，优先级高于任何新的 Task 和 UI 渲染

**V8 的优先级细化**：V8 会把任务划分成多个优先级队列（比如高优先级、普通优先级、低优先级），事件循环会优先消费高优先级队列的任务。举个例子：

- **高优先级**：用户交互事件（点击、输入）的回调，优先执行保证响应速度
- **普通优先级**：`setTimeout` 回调
- **低优先级**：`requestIdleCallback` 回调，只有浏览器空闲时才执行

#### 二、为什么 "宏任务 / 微任务" 的说法还在沿用？

"宏任务 = 宿主 Task"、"微任务 = 引擎 Job" 的对应关系，是开发者为了简化理解创造的通俗说法，它能快速解释清楚核心执行顺序：

```
同步代码 → 微任务队列全部执行 → （可选）UI 渲染 → 取一个宏任务执行 → 微任务队列全部执行 → 循环
```

这个抽象模型足够解决 99% 的前端异步问题（比如面试题、日常开发的异步顺序排障），所以至今还在广泛使用。

#### 三、清晰的执行顺序（规范视角）

1. 执行当前 Task 中的同步代码，直到调用栈为空
2. 执行所有 Job（微任务），包括执行 Job 过程中产生的新 Job，直到微任务队列为空
3. 浏览器判断是否需要渲染：满足屏幕刷新率（如 60Hz 对应 16.6ms 间隔）、有 DOM 变更、页面处于前台等条件，才会执行渲染
4. 从优先级最高的 Task 队列中取一个任务执行，回到步骤 1

### 宏任务与微任务的定义及常见类型

#### 宏任务（MacroTask）

宏任务通常是由宿主环境（浏览器或 Node.js）发起的异步任务。每次事件循环中只执行一个宏任务。常见的宏任务包括：

- `setTimeout`、`setInterval`
- I/O 操作
- UI 渲染
- 用户交互事件
- `requestAnimationFrame`
- 整体脚本代码（`<script>` 标签内的同步代码）也可视为一个宏任务

| 任务类型              | 浏览器 | Node.js |
| --------------------- | ------ | ------- |
| 整体代码 (script)     | ✅     | ✅      |
| UI 交互事件           | ✅     | ❌      |
| I/O                   | ✅     | ✅      |
| setTimeout            | ✅     | ✅      |
| setInterval           | ✅     | ✅      |
| setImmediate          | ❌     | ✅      |
| requestAnimationFrame | ✅     | ❌      |

#### 微任务（MicroTask）

微任务是高优先级的异步任务，由 JavaScript 自身发起，在当前宏任务执行完毕后立即执行，且在下一个宏任务开始前会清空微任务队列。常见的微任务有：

- `Promise.then`、`Promise.catch`、`Promise.finally`
- `queueMicrotask`
- `MutationObserver`

| 任务类型                   | 浏览器 | Node.js |
| -------------------------- | ------ | ------- |
| process.nextTick           | ❌     | ✅      |
| MutationObserver           | ✅     | ❌      |
| Promise.then/catch/finally | ✅     | ✅      |
| queueMicrotask             | ✅     | ✅      |

## 八、事件循环实战案例

### 案例一: async/await 的执行顺序

ECMAScript 2017 中添加了 `async functions` 和 `await`。

- **async 关键字**: 将一个同步函数变成一个异步函数,并将返回值变为 Promise
- **await 关键字**: 可以放在任何异步的、基于 Promise 的函数之前。在执行过程中,它会暂停代码在该行上,直到 Promise 完成,然后返回结果值。而在暂停的同时,其他正在等待执行的代码就有机会执行了

下面通过一个例子来深入理解:

```javascript
async function async1() {
  console.log("a");
  const res = await async2();
  console.log("b");
}

async function async2() {
  console.log("c");
  return 2;
}

console.log("d");

setTimeout(() => {
  console.log("e");
}, 0);

async1().then((res) => {
  console.log("f");
});

new Promise((resolve) => {
  console.log("g");
  resolve();
}).then(() => {
  console.log("h");
});

console.log("i");
```

**详细执行流程分析**:

1. **开始执行前**,将整体代码 script 放入宏任务队列中,并开始执行

2. **执行 `console.log("d")`**
   - 输出: `d`

3. **遇到 `setTimeout`**
   - 将其回调放入宏任务队列中
   - 继续执行

4. **调用 `async1()` 函数**
   - 将其函数上下文放置到调用栈

5. **执行 `async1` 中的 `console.log("a")`**
   - 输出: `a`

6. **遇到 `await` 关键字语句**
   - `await` 后面调用的是 `async2` 函数,将其放入调用栈

7. **执行 `async2` 中的 `console.log("c")`**
   - 输出: `c`
   - `async2` 返回值 `2`
   - `async2` 被移出调用栈

8. **`await` 阻塞执行**
   - `await` 会阻塞,先跳出 `async1` 继续往下执行
   - 此时 `async1` 中的 `res` 变量还是 `undefined`,没有赋值
   - `await` 后面的代码相当于放入了微任务队列

9. **执行 `new Promise`**
   - Promise 构造函数是同步执行的
   - 执行 `console.log("g")`
   - 输出: `g`
   - `then` 回调放入微任务队列

10. **执行 `console.log("i")`**
    - 输出: `i`

11. **第一个宏任务执行完毕**,开始清空微任务队列

12. **执行 Promise 的 then 微任务**
    - 执行 `console.log("h")`
    - 输出: `h`

13. **执行 `async1` 的 await 后续代码**
    - `res` 成功赋值为 `async2` 的结果值 `2`
    - 执行 `console.log("b")`
    - 输出: `b`
    - `async1` 执行结束

14. **执行 `async1().then()` 的回调**
    - 执行 `console.log("f")`
    - 输出: `f`

15. **微任务队列清空**,执行下一个宏任务

16. **执行 `setTimeout` 的回调**
    - 执行 `console.log("e")`
    - 输出: `e`

**最终输出结果**: `d` → `a` → `c` → `g` → `i` → `h` → `b` → `f` → `e`

### 关键知识点总结

1. **async 函数返回一个 Promise**,即使没有显式 return Promise
2. **await 会暂停 async 函数的执行**,等待 Promise 完成
3. **await 后面的代码相当于放在 Promise.then() 中**,会被放入微任务队列
4. **Promise 构造函数是同步执行的**,只有 then/catch/finally 才是异步的
5. **微任务优先于宏任务执行**

## 九、总结

1. **JavaScript 是单线程的**,但浏览器是多线程的,通过事件循环机制实现异步编程
2. **事件循环**是 JavaScript 实现异步的核心机制,理解它对掌握异步编程至关重要
3. **任务分为宏任务和微任务**,微任务优先级高于宏任务
4. **每次宏任务执行完毕后**,都会清空所有微任务队列,然后再执行下一个宏任务
5. **async/await 是 Promise 的语法糖**,但执行顺序需要特别注意

理解 Event Loop 对于编写高性能、无阻塞的 JavaScript 代码至关重要,也是前端开发者必须掌握的核心知识之一。

## Node.js 事件循环

### Libuv

在 JavaScript 的所有宿主环境中，无论是浏览器还是 Node.js，事件循环机制都不是 **ECMAScript** 的语言规范定义的。浏览器中的事件循环是根据 **HTML 标准**实现的，而 Node.js 中的事件循环则是基于 `libuv` 实现的。

`libuv` 是一个用 C 语言实现的高性能解决单线程非阻塞异步 I/O 的开源库，本质上它是对常见**操作系统底层异步 I/O 操作**的封装。在 nodejs 底层，Node API 的实现其实就是调用的它。

我们知道浏览器事件循环中执行异步任务的其他线程是由浏览器本身提供的，多线程调度是由渲染主线程完成的。而在 nodejs 中，这都是 `libuv` 完成的。

几乎每个 Node API 都有**异步执行版本**，`libuv` 直接负责它们的执行，`libuv` 会开启一个线程池，主线程执行到异步操作后，`libuv` 就会在**线程池**中调度空闲线程去执行，可以说 `libuv` 为 nodejs 提供了整个事件循环功能。

![libuv.webp](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c863acea121c4631ab7e2a827520a528~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1080&h=403&s=9242&e=webp&b=fdfaf9)

### Node.js 中的 Event Loop

与在浏览器中一样，在 nodejs 中 JS 最开始在**主线程**上执行，执行同步任务、发出异步请求、规划定时器生效时间、执行 process.nextTick 等，这时事件循环还没开始。

在上述过程中，如果没有异步操作，代码在执行完成后便**直接退出**。如果有，`libuv` 会把不同的异步任务分配给**不同的线程**，形成事件循环。在同步代码执行完后，nodejs 便会进入事件循环，依次执行不同队列中的任务。`libuv` 会以异步的方式将任务的执行结果返回给 **V8 引擎**，V8 引擎再返回给用户。

![nodejs 事件循环.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/4d7ac572250349c3b11f80f21e496481~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1336&h=1214&s=334402&e=png&b=fdfbfb)

Nodejs 事件循环中的消息队列共有 **8** 个，若引用之前宏队列、微队列的说法，具体可划分为：

- 宏队列
  - timers (重要)
  - pending callback
    - 调用上一次事件循环没在 `poll` 阶段立刻执行，而延迟的 I/O 回调函数
  - idle prepare
    - 仅供 nodejs 内部使用
  - poll (重要)
  - check (重要)
  - close callbacks
    - 执行所有注册 `close` 事件的回调函数
- 微队列
  - nextTick
  - Promise

我们先来说说宏队列中比较重要的 3 个：

📚 timers

`timers`，也就是**计时器队列**，负责处理 `setTimeout` 和 `setInterval` 定义的回调函数。

值得注意的是，不管在浏览器中还是 nodejs 中，所有的定时器回调函数都**不能保证**到达时间后立即执行。一是因为从计算机硬件和底层操作系统来看，计时器的实现本身就是不精准的，二是因为 `poll` 阶段对 `timers` 阶段的深刻影响。因为在没有满足 `poll` 阶段的结束条件前，就无法进入下一次事件循环的 `timers` 阶段，即使 `timers` 队列中已经有计时器到期的回调函数。

📚 poll

`poll` 称为**轮询队列**，该阶段会处理除 `timers` 和 `check` 队列外的绝大多数 I/O 回调任务，如文件读取、监听用户请求等。

事件循环到达该阶段时，它的运行方式为：

- 如果 `poll` 队列中有回调任务，则依次执行回调直到清空队列。
- 如果 `poll` 队列中没有回调任务
  - 若其他队列中后续可能会出现回调任务，则一直等待，等其他队列中后续的回调任务来临时，结束该阶段，开启下一次事件循环
  - 若等待时间超过预设的时间限制，也会自动进入下一次事件循环
  - 若其他队列中后续不可能再出现回调任务了，则立即结束该阶段，并在本轮事件循环完成后，退出 node 程序

> `poll` 阶段的超时时间在进入 `poll` 阶段之前计算。

💎 案例 1：不精准的计时器

```javascript
const fs = require("fs");
const start = Date.now();

setTimeout(() => {
  console.log("setTimeout exec", Date.now() - start);
}, 200);

fs.readFile("./index.js", "utf-8", (err, data) => {
  console.log("file read");
  const start = Date.now();
  while (Date.now() - start < 300) {}
});

// 输出结果：
// file read
// setTimeout exec 313ms
```

🔨 分析 1：

1.  进入事件循环后，定时器还没到时间，`timers` 队列空，来到 `poll` 阶段
2.  读取文件需要一定时间，`poll` 队列空，等待
3.  文件读取完成，回调函数加入 `poll` 队列，执行输出 `file read`，开启循环，阻塞 300ms
4.  定时器到时间，回调函数加入 `timers` 队列，由于 `poll` 阶段未结束，被阻塞，等待
5.  `poll` 中的循环结束，检测到 `timers` 中有任务，结束 `poll` 阶段，开始下一次事件循环
6.  执行 `timers` 中的回调函数，输出 `setTimeout exec 313ms`，计时器回调函数并没有在计时器到达时立即执行

📚 check

`check` 称为**检查队列**，负责处理 `setImmediate` 定义的回调函数。

`setTimeout` 和 `setImmediate` 的不同之处在于，每次执行到 `timers` 队列时，定时器观察者内部会去**检查**代码中的定时器是否超过定时时间，而 `setImmediate` 则是**直接**将回调任务**加入**到 `check` 队列。

所以总的来说，`setImmediate` 的执行效率要远高于 `setTimeout`，于是也就出现了下面**无法预测**输出结果的情况：

```javascript
setTimeout(() => {
  console.log("setTimeout");
}, 0);

setImmediate(() => {
  console.log("setImmediate");
});

// 上述代码是无法预测先输出那个的
// 因为即使 setTimeout(xxx, 0)，在计算机运算慢的情况下也不能立刻加入 timers 队列
```

对于微队列的 `nextTick` 和 `Promise`，严格意义上讲也不属于事件循环。在事件循环中，每次打算进入下个阶段之前，必须要先依次反复清空 `nextTick` 和 `promise` 队列，直到两个队列完全没有即将要到来的任务的时候再进入下个阶段。

我们可以通过 `process.nextTick()` 将回调函数加入 `nextTick` 队列，和通过 `Promise.resolve().then()` 将回调函数加入 `Promise` 队列，且 `nextTick` 队列的优先级还要**高于** `Promise` 队列，所以 `process.nextTick` 是 nodejs 中执行**最快**的异步操作。

💎 案例 2

```javascript
async function async1() {
  console.log("async1 start");
  await async2();
  console.log("async1 end");
}

async function async2() {
  console.log("async2");
}

console.log("script start");

setTimeout(function () {
  console.log("setTimeout0");
}, 0);

setTimeout(function () {
  console.log("setTimeout3");
}, 3);

setImmediate(() => console.log("setImmediate"));

process.nextTick(() => console.log("nextTick"));

async1();

new Promise(function (resolve) {
  console.log("promise1");
  resolve();
  console.log("promise2");
}).then(function () {
  console.log("promise3");
});

console.log("script end");

// 输出结果依次为：
// script start
// async1 start
// async2
// promise1
// promise2
// script end
// nextTick
// async1 end
// promise3
// 剩下的 setTimeout0、setTimeout3、setImmediate 顺序不定
// 唯一能确定的是 setTimeout0 在 setTimeout3 前输出
// 而 setImmediate 可能在 setTimeout0 前也可能在 setTimeout3 之后，也可能在两者中间
```

🔨 分析 2：

1.  执行全局代码，输出 `script start`。
2.  到达 `setTimeout(0)` 和 `setTimeout(3)`，交给计时器线程开始计时，注意在线程计时完成前，两个回调任务 `console.log` 还未加入 `timers` 队列。
3.  到达 `setImmediate`，立刻将 `console.log` 任务加入 `check` 队列。
4.  到达 `process.nextTick`，立刻将 `console.log` 任务加入 `nextTick` 队列。
5.  执行 `async1`，输出 `async1 start`。`await async2()` 立刻执行 `async2()`，输出 `async2` 将后续 `console.log` 任务包装成 `Promise.then()` 加入 `Promise` 队列。
6.  执行 `new Promise()`，输出 `promise1`、`promise2`，这两步是同步代码。然后将 `.then()` 里的 `console.log` 任务扔进 `Promise` 队列。
7.  执行最后的 `console.log`，输出 `script end`。
8.  至此同步代码全部执行完毕，消息队列中仍有任务，进入事件循环。

> 梳理一下此时各消息队列的状态：
>
> 已有的输出：`script start`、`async1 start`、`async2`、`promise1`、`promise2`、`script end`  
> `nextTick` 队列：`console.log("nextTick")`  
> `Promise` 队列：`console.log("async1 end")`、`console.log("promise3")`  
> `timers` 队列：`console.log("setTimeout0")`、`console.log("setTimeout3")`  
> `check` 队列：`console.log("setImmediate")`

9.  在进入 `timers` 阶段前先清空微队列，先执行 `nextTick` 队列，输出 `nextTick`。
10. 执行 `Promise` 队列，依次输出 `async1 end`、`promise3`。
11. 进入 `timers` 阶段，由于不确定在到达这个阶段前，计时器线程有没有把完成对 `setTimeout(0)` 和 `setTimeout(3)` 中的一者或两者的时间检查，并将回调函数推入 `timers` 队列，故无法预测它们与 `check` 队列中的 `setImmediate` 谁先输出。

---

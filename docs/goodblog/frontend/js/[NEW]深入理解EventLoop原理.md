# 深入理解 Event Loop 原理

## 一、进程与线程的区别

在了解 Event Loop 之前,我们需要先理解进程和线程的概念:

- **进程 (Process)**: 是操作系统进行资源分配和调度的基本单位,每个进程都有独立的内存空间
- **线程 (Thread)**: 是进程内的执行单元,一个进程可以包含多个线程,它们共享进程的内存空间
- **关系**: 进程好比工厂,线程好比工厂中的工人,多个工人(线程)协同完成工厂(进程)的任务

## 二、为什么 JavaScript 是单线程

> JavaScript 在设计之初是作为浏览器脚本语言,主要用于与用户进行页面交互和操纵 DOM。为避免由不可预测的用户操作可能带来的复杂的并发问题,JavaScript 被设计成单线程的,这也是这门语言的核心特征之一。

JavaScript 引擎之所以是单线程,主要有以下几个原因:

1. **避免 DOM 操作冲突**: 如果多个线程同时操作 DOM,可能会出现竞态条件和数据不一致的问题。假设线程 A 要删除某个 DOM 节点,而线程 B 要修改这个节点的样式,那么就会产生冲突
2. **简化编程模型**: 单线程避免了复杂的锁机制和线程同步问题
3. **历史设计**: JavaScript 最初只是一个简单的脚本语言,单线程足以满足当时的需求

## 三、浏览器的多进程架构

现代浏览器是一个多进程多线程的应用程序,内部工作极其复杂,其程度直逼操作系统。它拥有数个功能模块,为避免单个模块崩溃牵连其他模块,导致连锁反应使浏览器彻底崩溃,浏览器在启动时会开启多个进程,把不同的功能模块放在不同的进程里。

![浏览器多进程架构](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/ce3a90c15bd74f5b9513c2c2bfb9030d~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1518&h=1022&s=186040&e=png&b=fcf5f3)

浏览器进程众多,其中比较重要的有:

### 1. 浏览器进程

浏览器进程是浏览器的主进程,**无论打开多少浏览器窗口,它仅有一个**。

它主要负责:

- 浏览器界面显示(导航栏、书签栏、刷新按钮等)
- 用户交互处理
- 各子进程管理

> 注意: 这里说的界面和交互,不是视窗内的网站界面,而是指浏览器本身自带的部分。刚打开浏览器的时候只有一个浏览器进程,其他进程都是它创建的。

### 2. 网络进程

网络进程主要负责处理网站的数据请求和响应,通常情况下,它与渲染进程的交互最为密切。

工作流程:

1. 渲染进程需要请求资源时,将任务交给网络进程处理
2. 网络进程取得响应结果后返回给渲染进程
3. 网络进程内部开启多个线程,实现多网络请求的异步化处理

### 3. 渲染进程

渲染进程负责控制和显示视窗部分(网站页面)的所有内容,主要工作包括:

- 解析 HTML、CSS
- 生成渲染树
- 执行布局和绘制
- 执行 JavaScript 代码

**关键特性**:

- 在现代浏览器中,**默认会为每个标签页创建一个渲染进程**
- 出于安全考虑,渲染进程运行在沙箱模式下,无法访问系统资源

## 四、渲染进程的线程组成

虽然 JavaScript 是单线程的,但浏览器是多线程的。渲染进程内包含多个线程:

### 1. GUI 渲染线程

- 负责渲染浏览器界面,解析 HTML、CSS
- 构建 DOM 树和渲染树
- 进行布局和绘制
- **与 JS 引擎线程互斥**: 当 JS 引擎执行时,GUI 线程会被挂起,GUI 更新会被保存在队列中等待 JS 引擎空闲时立即执行

### 2. JS 引擎线程

- 也叫 JS 内核,负责解析执行 JavaScript 脚本程序的主线程(例如 V8 引擎)
- 一直等待着任务队列中任务的到来,然后加以处理
- **一个 Tab 页(渲染进程)中无论什么时候都只有一个 JS 线程在运行 JS 程序**

### 3. 事件触发线程

- 属于浏览器内核线程,主要用于控制事件循环
- 当 JS 引擎执行代码块如 `setTimeout` 时(也可来自浏览器内核的其他线程,如鼠标点击、AJAX 异步请求等)
- 会将对应任务添加到事件触发线程中
- 当对应的事件符合触发条件被触发时,该线程会把事件添加到待处理队列的队尾,等待 JS 引擎的处理

### 4. 定时器触发线程

- 主要控制 `setInterval` 和 `setTimeout`
- 浏览器定时计数器并不是由 JavaScript 引擎计数的,因为 JavaScript 引擎是单线程的,如果处于阻塞线程状态就会影响记计时的准确性
- 当计时完毕后,会把定时器的处理函数推进事件队列中,等待 JS 引擎线程执行

### 5. 异步 HTTP 请求线程

- 在 XMLHttpRequest 连接后通过浏览器新开的一个线程请求
- 检测到状态变更时,如果设置有回调函数,该线程会把回调函数推进事件队列中,等待 JS 引擎线程执行

## 五、渲染主线程与事件循环

渲染进程启动后,会开启一个**渲染主线程**,它是浏览器中最繁忙的线程,需要处理的任务包括但不限于:

- 解析 HTML、CSS
- 计算样式、布局
- 处理图层、绘制页面
- 执行 JavaScript 代码
- 执行各种回调函数

### 消息队列机制

渲染主线程一个线程要处理好这么多任务,那如何进行任务调度便成了重点,而**浏览器采用的则是排队机制**。

浏览器会提供一个**先进先出的消息队列**(也称任务队列),用于存储待执行的任务:

1. 渲染主线程不断依次从消息队列中取出任务执行
2. 遇到异步操作则交给其他线程处理
3. 异步操作完成后,响应结果再次加入消息队列
4. 等待渲染主线程拿取执行

如此,所有的任务都能有条不紊地进行,而**这个过程便是事件循环(Event Loop)**(也称消息循环)。

### 多队列优先级

任务在消息队列里先进先出并没有优先级,但**浏览器中消息队列不止一条,它们是有优先级的**。

过去我们把消息队列分为**宏队列**和**微队列**:

- **宏队列**: 排队宏任务(DOM 操作回调、定时器回调、UI 绘制等)
- **微队列**: 排队微任务(Promise 回调等)
- 渲染主线程的每次循环会**优先执行并清空微队列任务**,再执行宏队列

不过随着时间推移,浏览器复杂度急剧提升,仅两个队列已经不能满足现代浏览器的需求了。于是,**W3C 在制定 HTML 规范的时候已抛弃宏队列的说法**。

### 现代浏览器的队列实现

各浏览器厂商在实现事件循环时会根据最新的 W3C 规范:

> 每个任务都有其任务类型,同一个类型的任务必须在同一个队列里排队。在一次事件循环中,浏览器可根据实际情况从不同的队列中取出任务执行。并且浏览器必须准备好一个微队列,其中的任务优先于所有其他队列的任务执行。

不同浏览器,除微队列外,队列的种类和数量均可能不同,这取决于浏览器厂商。

**在目前的 Chrome 实现中,至少包含了下面几个队列**:

1. **微队列**: 用于存放需要最快执行的任务,优先级极高,将任务加入微队列的方式有 `Promise.then()`、`MutationObserver`
2. **交互队列**: 用于存放用户操作后产生的事件处理任务,优先级次于微队列
3. **延迟队列**: 用于存放定时器到达后的回调任务,优先级次于交互队列

> ⚠️ **特别注意**: 人工合成的事件派发,即直接写在代码里的 `dom.click()` 或 `dispatchEvent()`,相对于浏览器而言并不是真正的用户交互,会被当作同步任务执行。只有用户动作触发的事件,才会作为异步任务,在事件循环中等待执行。

**参考链接**: [MDN - EventTarget.dispatchEvent()](https://developer.mozilla.org/zh-CN/docs/Web/API/EventTarget/dispatchEvent)

## 六、事件循环的工作原理

### 什么是事件循环

单线程意味着 JavaScript 引擎在同一时间只能做一件事情,即同步地执行代码。但在代码执行过程中不可避免地会遇到一些无法立即执行的任务,例如:

- 计时器到达时间后要执行的任务 → `setInterval`、`setTimeout`
- 网络请求完成后要执行的任务 → `XMLHttpRequest`、`Fetch`
- 监听到用户操作后要执行的任务 → `addEventListener`

如果让执行 JavaScript 的线程去处理这些任务,就会导致该线程处于长期阻塞的状态,而宿主环境中的 JavaScript 执行线程往往还承担着极其重要的工作。例如,在浏览器中,如果执行 JavaScript 的线程长期阻塞,就会导致浏览器卡死!

为避免上述情况发生,**JavaScript 的宿主环境使用了异步的方式来处理这种无法立即执行的任务**。

当遇到异步任务时:

1. 宿主环境会将其交给其他线程处理
2. 执行 JavaScript 的线程则会立即结束当前任务
3. 转而去执行后续代码

### 事件循环流程图

![事件循环流程](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdd88994142347~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp)

**事件循环的基本流程**:

1. 同步任务和异步任务分别进入不同的执行"场所",同步的进入主线程,异步的进入 Event Table 并注册函数
2. 当指定的事情完成时,Event Table 会将这个函数移入 Event Queue
3. 主线程内的任务执行完毕为空,会去 Event Queue 读取对应的函数,进入主线程执行
4. 上述过程会不断重复,也就是常说的 **Event Loop(事件循环)**

### 主线程如何知道执行栈为空

从谷歌浏览器源码来看,渲染进程进入渲染流程,渲染主线程便会开启一个**无限循环**。

每次循环都会检查消息队列中是否有任务:

- **如果有**: 就拿出队列中的第一个任务执行,执行过程中若遇到异步操作,渲染主线程会将其加入其他线程的任务队列进行处理,它自己则不会等待,转而去执行后续代码
- **如果没有**: 则进入休眠状态

当其他线程把异步任务处理完成,就会将后续的回调操作包装成新任务,加入消息队列末尾,等待渲染主线程拿取执行。

其他所有线程,包括其他进程的线程,都可以往消息队列末尾添加任务。当新任务添加时如果主线程处于休眠状态,则会将其唤醒以继续循环拿取任务执行。

### 事件循环的执行顺序

**事件循环的顺序,决定了 JavaScript 代码的执行顺序**。进入整体代码(宏任务)后,开始第一次循环。接着执行所有的微任务。然后再次从宏任务开始,找到其中一个任务队列执行完毕,再执行所有的微任务。

![事件循环关系图](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/11/21/15fdcea13361a1ec~tplv-t2oaga2asx-zoom-in-crop-mark:1512:0:0:0.awebp)

#### 示例代码分析

```javascript
setTimeout(function () {
  console.log("setTimeout");
});

new Promise(function (resolve) {
  console.log("promise");
  resolve();
}).then(function () {
  console.log("then");
});

console.log("console");
```

**执行流程分析**:

1. 这段代码作为宏任务,进入主线程
2. 先遇到 `setTimeout`,将其回调函数注册后分发到宏任务 Event Queue
3. 接下来遇到了 `Promise`,`new Promise` **立即执行**,输出 `'promise'`,`then` 函数分发到微任务 Event Queue
4. 遇到 `console.log()`,立即执行,输出 `'console'`
5. 第一个宏任务执行结束,检查微任务队列,发现 `then` 在微任务 Event Queue 里面,执行,输出 `'then'`
6. 第一轮事件循环结束,开始第二轮循环,从宏任务 Event Queue 开始,发现 `setTimeout` 对应的回调函数,立即执行,输出 `'setTimeout'`
7. 结束

**输出结果**: `promise` → `console` → `then` → `setTimeout`

## 七、宏任务与微任务

### 宏任务 (MacroTask)

| 任务类型              | 浏览器 | Node.js |
| --------------------- | ------ | ------- |
| 整体代码 (script)     | ✅     | ✅      |
| UI 交互事件           | ✅     | ❌      |
| I/O                   | ✅     | ✅      |
| setTimeout            | ✅     | ✅      |
| setInterval           | ✅     | ✅      |
| setImmediate          | ❌     | ✅      |
| requestAnimationFrame | ✅     | ❌      |

### 微任务 (MicroTask)

| 任务类型                   | 浏览器 | Node.js |
| -------------------------- | ------ | ------- |
| process.nextTick           | ❌     | ✅      |
| MutationObserver           | ✅     | ❌      |
| Promise.then/catch/finally | ✅     | ✅      |

## 八、事件循环实战案例

### 案例一: async/await 的执行顺序

ECMAScript 2017 中添加了 `async functions` 和 `await`。

- **async 关键字**: 将一个同步函数变成一个异步函数,并将返回值变为 Promise
- **await 关键字**: 可以放在任何异步的、基于 Promise 的函数之前。在执行过程中,它会暂停代码在该行上,直到 Promise 完成,然后返回结果值。而在暂停的同时,其他正在等待执行的代码就有机会执行了

下面通过一个例子来深入理解:

```javascript
async function async1() {
  console.log("a");
  const res = await async2();
  console.log("b");
}

async function async2() {
  console.log("c");
  return 2;
}

console.log("d");

setTimeout(() => {
  console.log("e");
}, 0);

async1().then((res) => {
  console.log("f");
});

new Promise((resolve) => {
  console.log("g");
  resolve();
}).then(() => {
  console.log("h");
});

console.log("i");
```

**详细执行流程分析**:

1. **开始执行前**,将整体代码 script 放入宏任务队列中,并开始执行

2. **执行 `console.log("d")`**
   - 输出: `d`

3. **遇到 `setTimeout`**
   - 将其回调放入宏任务队列中
   - 继续执行

4. **调用 `async1()` 函数**
   - 将其函数上下文放置到调用栈

5. **执行 `async1` 中的 `console.log("a")`**
   - 输出: `a`

6. **遇到 `await` 关键字语句**
   - `await` 后面调用的是 `async2` 函数,将其放入调用栈

7. **执行 `async2` 中的 `console.log("c")`**
   - 输出: `c`
   - `async2` 返回值 `2`
   - `async2` 被移出调用栈

8. **`await` 阻塞执行**
   - `await` 会阻塞,先跳出 `async1` 继续往下执行
   - 此时 `async1` 中的 `res` 变量还是 `undefined`,没有赋值
   - `await` 后面的代码相当于放入了微任务队列

9. **执行 `new Promise`**
   - Promise 构造函数是同步执行的
   - 执行 `console.log("g")`
   - 输出: `g`
   - `then` 回调放入微任务队列

10. **执行 `console.log("i")`**
    - 输出: `i`

11. **第一个宏任务执行完毕**,开始清空微任务队列

12. **执行 Promise 的 then 微任务**
    - 执行 `console.log("h")`
    - 输出: `h`

13. **执行 `async1` 的 await 后续代码**
    - `res` 成功赋值为 `async2` 的结果值 `2`
    - 执行 `console.log("b")`
    - 输出: `b`
    - `async1` 执行结束

14. **执行 `async1().then()` 的回调**
    - 执行 `console.log("f")`
    - 输出: `f`

15. **微任务队列清空**,执行下一个宏任务

16. **执行 `setTimeout` 的回调**
    - 执行 `console.log("e")`
    - 输出: `e`

**最终输出结果**: `d` → `a` → `c` → `g` → `i` → `h` → `b` → `f` → `e`

### 关键知识点总结

1. **async 函数返回一个 Promise**,即使没有显式 return Promise
2. **await 会暂停 async 函数的执行**,等待 Promise 完成
3. **await 后面的代码相当于放在 Promise.then() 中**,会被放入微任务队列
4. **Promise 构造函数是同步执行的**,只有 then/catch/finally 才是异步的
5. **微任务优先于宏任务执行**

## 九、总结

1. **JavaScript 是单线程的**,但浏览器是多线程的,通过事件循环机制实现异步编程
2. **事件循环**是 JavaScript 实现异步的核心机制,理解它对掌握异步编程至关重要
3. **任务分为宏任务和微任务**,微任务优先级高于宏任务
4. **每次宏任务执行完毕后**,都会清空所有微任务队列,然后再执行下一个宏任务
5. **async/await 是 Promise 的语法糖**,但执行顺序需要特别注意

理解 Event Loop 对于编写高性能、无阻塞的 JavaScript 代码至关重要,也是前端开发者必须掌握的核心知识之一。

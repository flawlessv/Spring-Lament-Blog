# 万字长文带你理清楚前端跨域所有解决方案的细节

> 前段时间chrome更新了204版本之后，由于新版的chrome把iframe 放在了独立的进程渲染，导致公司的的一个angular子应用使用iframe嵌套在主应用中发生了跨域，心想在解决问题的时候顺便把跨域相关的知识全部整理一遍吧

## 一、什么是跨域?

跨域问题本质上是浏览器的**同源策略**(Same-Origin Policy, SOP)造成的。这是浏览器的一个安全机制,用来保护用户的隐私和数据安全。

### 理解"源"的概念

在我刚开始学习前端时,对"源"这个概念有点模糊。后来我发现,其实很简单——一个 URL 的"源"就是由**协议**、**域名**和**端口号**三部分组成的。只有这三者**完全相同**,浏览器才认为是同源。

举个例子,我来对比几个 URL:

```
https://www.example.com:443/api/users
```

与下面这些 URL 是否同源?

```
http://www.example.com:443/api/users       ✗ 协议不同(https vs http)
https://api.example.com:443/api/users      ✗ 域名不同(www vs api)
https://www.example.com:8080/api/users     ✗ 端口不同(443 vs 8080)
https://www.example.com:443/api/posts      ✓ 同源(只是路径不同)
```

### 同源策略限制了什么?

同源策略主要限制以下几个方面:

1. **Ajax 请求**: 可以向不同源服务器发起请求，但浏览器会限制 JavaScript 代码读取非同源响应的内容（比如无法访问 response 数据）。也就是说，跨域的 Ajax 请求可以发出，但响应会被同源策略拦截，页面拿不到数据。这就是常见的“跨域请求被阻止”问题。
2. **DOM 访问**: 不能访问跨域 iframe 的 DOM
3. **Cookie/LocalStorage/IndexDB**: 不能读取跨域的存储数据

```mermaid
graph TD
    A[浏览器页面] -->|同源请求| B[同源服务器]
    A -->|跨域请求| C[跨域服务器]
    B -->|正常响应| A
    C -->|响应| D{CORS检查}
    D -->|有CORS头| A
    D -->|无CORS头| E[被浏览器阻止]
```

## 二、前端跨域解决方案详解

接下来,我会详细介绍我在实际项目中用过的各种跨域解决方案,每种方案都会给出完整的代码示例和优劣势分析。

### 方案一:CORS(跨域资源共享)⭐⭐⭐⭐⭐

CORS 是我最推荐的跨域解决方案,也是现代 Web 开发的标准做法。它通过服务器设置响应头来告诉浏览器:"这个跨域请求是允许的"。

#### 实现示例

**前端代码**(不需要特殊处理):

```javascript
// 使用 fetch
fetch("https://api.example.com/users", {
  method: "POST",
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({ name: "John" }),
})
  .then((response) => response.json())
  .then((data) => console.log(data))
  .catch((error) => console.error("Error:", error));
```

**后端代码**(Node.js + Express):

```javascript
const express = require("express");
const app = express();

// 安全配置 - 只允许特定域名
app.use((req, res, next) => {
  const allowedOrigins = ["https://www.mysite.com", "https://app.mysite.com"];
  const origin = req.headers.origin;

  if (allowedOrigins.includes(origin)) {
    res.header("Access-Control-Allow-Origin", origin);
  }

  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE");
  res.header("Access-Control-Allow-Headers", "Content-Type, Authorization");
  res.header("Access-Control-Allow-Credentials", "true"); // 允许携带 Cookie
  res.header("Access-Control-Max-Age", "86400"); // 预检请求缓存 24 小时

  if (req.method === "OPTIONS") {
    return res.sendStatus(200);
  }
  next();
});

app.post("/users", (req, res) => {
  res.json({ message: "User created successfully" });
});

app.listen(3000);
```

#### CORS 的两种请求类型

在使用 CORS 时,我发现请求分为两种类型:

**1. 简单请求**

满足以下条件的请求:

- 请求方法是 GET、HEAD 或 POST
- Content-Type 是 text/plain、multipart/form-data 或 application/x-www-form-urlencoded
- 没有自定义请求头

简单请求会直接发送,浏览器自动在请求头加上 `Origin` 字段。

**2. 预检请求(Preflight)**

不满足简单请求条件的,浏览器会先发送一个 OPTIONS 请求进行"预检":

```
OPTIONS /users HTTP/1.1
Origin: https://www.mysite.com
Access-Control-Request-Method: PUT
Access-Control-Request-Headers: Content-Type
```

服务器响应后,浏览器才会发送真正的请求。

#### 优劣势分析

**优势:**

- ✅ 标准化方案,浏览器原生支持
- ✅ 支持所有 HTTP 方法(GET、POST、PUT、DELETE 等)
- ✅ 安全性高,服务器可以精确控制哪些域名可以访问
- ✅ 支持携带 Cookie 和自定义请求头

**劣势:**

- ❌ 需要服务器端配置支持
- ❌ 老旧浏览器(IE10 以下)支持不完善
- ❌ 预检请求会增加一次 HTTP 请求(可通过 max-age 缓存优化)

**适用场景:**

- 现代 Web 应用的首选方案
- 需要支持复杂请求的场景
- 有服务器控制权的项目

---

### 方案二:JSONP ⭐⭐

#### 原理说明

JSONP 利用了 `<script>` 标签不受同源策略限制的特性。原理就是:

1. 前端定义一个回调函数
2. 创建一个 `<script>` 标签,src 指向跨域 URL,并带上回调函数名
3. 服务器返回一段 JavaScript 代码,调用这个回调函数并传入数据
4. 浏览器执行这段代码,数据就被传递给了回调函数

#### 实现示例

**前端代码**:

```javascript
// 手动实现 JSONP
function jsonp(url, callbackName, callback) {
  // 创建 script 标签
  const script = document.createElement("script");

  // 定义全局回调函数
  window[callbackName] = function (data) {
    callback(data);
    // 清理
    document.body.removeChild(script);
    delete window[callbackName];
  };

  // 设置 src,拼接回调函数名
  script.src = `${url}?callback=${callbackName}`;
  document.body.appendChild(script);
}

// 使用示例
jsonp("https://api.example.com/users", "handleUserData", function (data) {
  console.log("收到数据:", data);
});
```

#### 优劣势分析

**优势:**

- ✅ 兼容性好,支持老旧浏览器(IE6+)
- ✅ 实现简单,不需要复杂配置
- ✅ 前端可以完全控制,不依赖服务器特殊配置

**劣势:**

- ❌ 只支持 GET 请求
- ❌ 安全性低,容易受到 XSS 攻击
- ❌ 错误处理困难,无法获取 HTTP 状态码
- ❌ 服务器必须专门为 JSONP 返回特定格式
- ❌ 可能遭受 CSRF 攻击

**适用场景:**

- 只需要 GET 请求获取数据
- 需要兼容非常老的浏览器
- 第三方服务只提供 JSONP 接口(如早期的一些地图、天气 API)

**现状:** 由于安全性和功能限制,JSONP 已经逐渐被 CORS 取代,不建议在新项目中使用。

---

### 方案三:开发环境代理(Webpack DevServer / Vite) ⭐⭐⭐⭐⭐

这是我在开发环境中最常用的方案。通过配置开发服务器代理,让它帮我们转发请求,完全不需要修改业务代码。

#### Webpack DevServer 配置

**webpack.config.js**:

```javascript
module.exports = {
  devServer: {
    port: 8080,
    proxy: {
      "/api": {
        target: "http://localhost:3000",
        changeOrigin: true,
        pathRewrite: { "^/api": "" },
      },
      // WebSocket 代理
      "/socket.io": {
        target: "http://localhost:3000",
        ws: true,
        changeOrigin: true,
      },
    },
  },
};
```

#### Vite 配置

**vite.config.js**:

```javascript
import { defineConfig } from "vite";

export default defineConfig({
  server: {
    port: 5173,
    proxy: {
      "/api": {
        target: "http://localhost:3000",
        changeOrigin: true,
        rewrite: (path) => path.replace(/^\/api/, ""),
      },
    },
  },
});
```

#### Create React App 配置

**src/setupProxy.js**:

```javascript
const { createProxyMiddleware } = require("http-proxy-middleware");

module.exports = function (app) {
  app.use(
    "/api",
    createProxyMiddleware({
      target: "http://localhost:3000",
      changeOrigin: true,
      pathRewrite: { "^/api": "" },
    })
  );
};
```

#### Next.js 配置

**next.config.js**:

```javascript
module.exports = {
  async rewrites() {
    return [
      {
        source: "/api/:path*",
        destination: "http://localhost:3000/:path*",
      },
    ];
  },
};
```

#### 优劣势分析

**优势:**

- ✅ 前端代码无需任何改动
- ✅ 配置简单,开箱即用
- ✅ 支持所有 HTTP 方法和请求类型
- ✅ 完美模拟生产环境
- ✅ 支持 WebSocket 代理
- ✅ 可以同时代理多个后端服务

**劣势:**

- ❌ 仅适用于开发环境
- ❌ 生产环境需要其他方案(如 Nginx)
- ❌ 每个项目都需要配置

**适用场景:**

- 本地开发调试
- 前后端分离项目
- 微服务架构

---

### 方案四:Nginx 反向代理 ⭐⭐⭐⭐⭐

Nginx 反向代理是我在生产环境中最常用的方案。它性能好、稳定可靠,适合处理高并发场景。

#### 基本配置

**nginx.conf**:

```nginx
server {
    listen 80;
    server_name www.mysite.com;

    # 前端静态文件
    location / {
        root /var/www/html;
        index index.html;
        try_files $uri $uri/ /index.html; # 支持 SPA 路由
    }

    # 代理后端 API
    location /api/ {
        proxy_pass http://localhost:3000/; # 注意末尾的斜杠
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

#### 高级配置

```nginx
# 负载均衡配置
upstream backend {
    server 127.0.0.1:3000 weight=3;
    server 127.0.0.1:3001 weight=2;
    server 127.0.0.1:3002 weight=1;
    keepalive 32; # 保持连接数
}

server {
    listen 80;
    server_name www.mysite.com;

    # 启用 gzip 压缩
    gzip on;
    gzip_types text/plain text/css application/json application/javascript text/xml application/xml;
    gzip_min_length 1000;

    # 前端静态资源
    location / {
        root /var/www/html;
        index index.html;
        try_files $uri $uri/ /index.html;

        # 静态资源缓存
        location ~* \.(jpg|jpeg|png|gif|ico|css|js)$ {
            expires 7d;
            add_header Cache-Control "public, immutable";
        }
    }

    # API 代理(去掉 /api 前缀)
    location /api/ {
        proxy_pass http://backend/; # 使用负载均衡

        # 重写路径(可选)
        rewrite ^/api/(.*)$ /$1 break;

        # 设置请求头
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;

        # 超时配置
        proxy_connect_timeout 30s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;

        # 缓冲配置
        proxy_buffering on;
        proxy_buffer_size 4k;
        proxy_buffers 8 4k;

        # WebSocket 支持
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    # WebSocket 专用配置
    location /socket.io/ {
        proxy_pass http://localhost:3000/socket.io/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host $host;
        proxy_cache_bypass $http_upgrade;
    }

    # 文件上传
    location /upload {
        client_max_body_size 100M; # 最大上传大小
        proxy_pass http://localhost:3000/upload;
        proxy_request_buffering off; # 禁用请求缓冲,支持大文件上传
    }
}

# HTTPS 配置
server {
    listen 443 ssl http2;
    server_name www.mysite.com;

    ssl_certificate /path/to/cert.pem;
    ssl_certificate_key /path/to/key.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers HIGH:!aNULL:!MD5;

    # 其他配置同上...
}

# HTTP 重定向到 HTTPS
server {
    listen 80;
    server_name www.mysite.com;
    return 301 https://$server_name$request_uri;
}
```

#### Docker 环境配置

**docker-compose.yml**:

```yaml
version: "3.8"

services:
  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./dist:/var/www/html
    depends_on:
      - backend

  backend:
    image: node:18-alpine
    command: npm start
    ports:
      - "3000:3000"
    volumes:
      - ./backend:/app
    working_dir: /app
```

#### 优劣势分析

**优势:**

- ✅ 性能极佳,处理静态文件和反向代理非常高效
- ✅ 支持负载均衡,可以分发请求到多个后端服务
- ✅ 配置灵活,支持各种复杂场景
- ✅ 生产环境首选方案
- ✅ 支持 HTTPS、HTTP/2、gzip 压缩等
- ✅ 可以统一管理前后端服务

**劣势:**

- ❌ 需要服务器和 Nginx 配置权限
- ❌ 学习曲线相对陡峭
- ❌ 配置错误可能导致服务不可用
- ❌ 本地开发环境需要安装 Nginx

**适用场景:**

- 生产环境部署
- 高并发场景
- 需要负载均衡的场景
- 同时部署多个服务的场景

---

### 方案五:postMessage(页面间通信) ⭐⭐⭐⭐

`postMessage` 是我在处理 iframe 跨域通信时最常用的方法,它安全可靠,浏览器原生支持。

#### 基本使用

**父页面**(www.a.com/parent.html):

```html
<iframe id="childFrame" src="https://www.b.com/child.html"></iframe>
<button onclick="sendMessage()">发送消息到子页面</button>

<script>
  const iframe = document.getElementById("childFrame");

  // 发送消息
  function sendMessage() {
    iframe.contentWindow.postMessage(
      { type: "greeting", message: "Hello from parent!" },
      "https://www.b.com"
    );
  }

  // 接收消息
  window.addEventListener("message", function (event) {
    if (event.origin !== "https://www.b.com") return;
    console.log("父页面收到消息:", event.data);
  });
</script>
```

**子页面**(www.b.com/child.html):

```html
<script>
  // 发送消息到父页面
  window.parent.postMessage(
    { type: "response", message: "Hello from child!" },
    "https://www.a.com"
  );

  // 接收消息
  window.addEventListener("message", function (event) {
    if (event.origin !== "https://www.a.com") return;
    console.log("子页面收到消息:", event.data);
  });
</script>
```

#### 优劣势分析

**优势:**

- ✅ 浏览器原生支持,无需额外库
- ✅ 安全性高,可以验证消息来源
- ✅ 支持跨域 iframe、window.open 等多种场景
- ✅ 可以传递复杂数据结构(会自动序列化)
- ✅ 双向通信

**劣势:**

- ❌ 只适用于页面间通信,不能用于 HTTP 请求
- ❌ 需要双方都实现消息监听
- ❌ 调试相对困难
- ❌ 消息传递是异步的

**适用场景:**

- iframe 嵌入第三方页面的通信
- 主应用与微前端子应用的通信
- 浏览器标签页/窗口间通信

---

### 方案六:WebSocket ⭐⭐⭐⭐

WebSocket 不受同源策略限制,我主要在需要实时双向通信的场景使用它。

#### 基本使用

**前端代码**:

```javascript
const ws = new WebSocket("wss://api.example.com/socket");

ws.onopen = () => {
  console.log("连接已建立");
  ws.send(JSON.stringify({ type: "join", room: "chat-1" }));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log("收到消息:", data);
};

ws.onclose = () => console.log("连接已关闭");
ws.onerror = (error) => console.error("错误:", error);
```

#### 优劣势分析

**优势:**

- ✅ 不受同源策略限制,可以连接任何域名
- ✅ 全双工通信,服务器可以主动推送消息
- ✅ 实时性好,延迟低
- ✅ 协议开销小,性能好
- ✅ 支持二进制数据传输

**劣势:**

- ❌ 需要服务器支持 WebSocket 协议
- ❌ 长连接占用服务器资源
- ❌ 老旧浏览器支持不完善
- ❌ 需要处理断线重连、心跳检测等复杂逻辑
- ❌ 部分代理服务器可能不支持

**适用场景:**

- 实时聊天应用
- 在线游戏
- 实时数据监控(如股票行情)
- 协同编辑(如在线文档)
- 消息推送

---

### 方案七:window.name ⭐

`window.name` 是一个比较古老的方案,已很少使用。原理是利用 `window.name` 在页面跨域跳转时会保留的特性。

#### 简要说明

1. 在 A 页面创建 iframe 指向 B 页面(跨域)
2. B 页面将数据写入 `window.name`
3. 将 iframe 的 src 改为 A 的同源页面
4. A 页面读取 iframe 的 `window.name`

**优势:** 可传输大量数据(约 2MB)、兼容老浏览器

**劣势:** 需要两次页面加载、效率低、用户体验差

**现状:** 已很少使用,建议优先考虑 postMessage 或 CORS。

---

### 方案八:document.domain ⭐(已废弃)

这个方案我几乎没用过,因为它的适用场景非常有限,而且现代浏览器已经逐步废弃了这个特性。

#### 原理说明

`document.domain` 只适用于**主域相同、子域不同**的情况。通过将两个页面的 `document.domain` 都设置为主域,浏览器就会认为它们是同源的。

#### 实现示例

**页面 A**(www.a.example.com/a.html):

```html
<!DOCTYPE html>
<html>
  <head>
    <title>页面 A</title>
  </head>
  <body>
    <h1>页面 A (www.a.example.com)</h1>
    <iframe id="iframe" src="https://www.b.example.com/b.html"></iframe>

    <script>
      // 将 document.domain 设置为主域
      document.domain = "example.com";

      window.onload = function () {
        const iframe = document.getElementById("iframe");

        // 现在可以访问 iframe 的内容了
        const iframeDoc =
          iframe.contentDocument || iframe.contentWindow.document;
        console.log("iframe 的标题:", iframeDoc.title);

        // 可以操作 iframe 的 DOM
        const h1 = iframeDoc.querySelector("h1");
        h1.style.color = "red";

        // 可以调用 iframe 的函数
        iframe.contentWindow.someFunction();
      };
    </script>
  </body>
</html>
```

**页面 B**(www.b.example.com/b.html):

```html
<!DOCTYPE html>
<html>
  <head>
    <title>页面 B</title>
  </head>
  <body>
    <h1>页面 B (www.b.example.com)</h1>

    <script>
      // 同样设置 document.domain 为主域
      document.domain = "example.com";

      function someFunction() {
        console.log("iframe 的函数被调用了");
      }

      // 也可以访问父页面
      console.log("父页面的标题:", window.parent.document.title);
    </script>
  </body>
</html>
```

#### 优劣势分析

**优势:**

- ✅ 可以完全访问 DOM 和 JavaScript 对象
- ✅ 双向通信
- ✅ 实现简单

**劣势:**

- ❌ 只适用于主域相同、子域不同的情况
- ❌ 现代浏览器(Chrome 109+)已默认禁用
- ❌ 安全性较低
- ❌ 只能设置为当前域名或更高级的父域名

**适用场景:**

- 主域相同、子域不同的 iframe 通信
- 老旧项目的维护

**现状:** 这个特性已被废弃,Chrome 109+ 默认禁用。**强烈建议使用 postMessage 替代**。

---

## 三、方案对比与选择

经过这么多项目实践,我总结了一个选择流程:

```mermaid
graph TD
    Start[遇到跨域问题] --> Q1{是否有服务器控制权?}
    Q1 -->|是| Q2{开发环境还是生产环境?}
    Q1 -->|否| Q3{是页面间通信吗?}

    Q2 -->|开发环境| Dev[使用开发代理<br/>Webpack/Vite Proxy]
    Q2 -->|生产环境| Prod{需要负载均衡?}

    Prod -->|是| Nginx[使用 Nginx 反向代理]
    Prod -->|否| CORS[使用 CORS]

    Q3 -->|是| PostMessage[使用 postMessage]
    Q3 -->|否| Q4{需要实时通信?}

    Q4 -->|是| WS[使用 WebSocket]
    Q4 -->|否| Q5{只支持 GET 请求?}

    Q5 -->|是| JSONP[使用 JSONP<br/>不推荐]
    Q5 -->|否| NoSolution[联系后端添加 CORS 支持]
```

### 综合对比表

| 方案            | 推荐指数   | 适用环境   | 支持请求类型   | 实现难度 | 安全性 | 性能 |
| --------------- | ---------- | ---------- | -------------- | -------- | ------ | ---- |
| CORS            | ⭐⭐⭐⭐⭐ | 生产环境   | 所有 HTTP 方法 | 简单     | 高     | 优秀 |
| 开发代理        | ⭐⭐⭐⭐⭐ | 开发环境   | 所有 HTTP 方法 | 非常简单 | -      | 优秀 |
| Nginx 反向代理  | ⭐⭐⭐⭐⭐ | 生产环境   | 所有 HTTP 方法 | 中等     | 高     | 极佳 |
| postMessage     | ⭐⭐⭐⭐   | 页面间通信 | 消息传递       | 简单     | 高     | 良好 |
| WebSocket       | ⭐⭐⭐⭐   | 实时通信   | WebSocket 协议 | 中等     | 高     | 优秀 |
| JSONP           | ⭐⭐       | 老旧浏览器 | 仅 GET         | 简单     | 低     | 良好 |
| window.name     | ⭐         | 大数据传输 | 单向传递       | 复杂     | 中     | 差   |
| document.domain | ⭐(已废弃) | 子域通信   | DOM 访问       | 简单     | 低     | 良好 |

---

## 四、实战场景与最佳实践

在实际开发中,我经常会遇到以下几种场景:

### 场景一:前后端分离项目

**开发环境:**

```javascript
// vite.config.js
export default defineConfig({
  server: {
    proxy: {
      "/api": {
        target: "http://localhost:3000",
        changeOrigin: true,
      },
    },
  },
});

// 前端代码使用相对路径
fetch("/api/users").then((res) => res.json());
```

**生产环境:**

```nginx
# nginx.conf
server {
    listen 80;
    server_name www.mysite.com;

    location / {
        root /var/www/html;
        try_files $uri /index.html;
    }

    location /api/ {
        proxy_pass http://backend-service:3000/;
    }
}
```

### 场景二:微前端架构

```javascript
// 主应用
class MicroApp {
  constructor(container, url) {
    this.container = container;
    this.url = url;
    this.iframe = null;
    this.bridge = null;
  }

  mount() {
    this.iframe = document.createElement("iframe");
    this.iframe.src = this.url;
    this.container.appendChild(this.iframe);

    // 建立通信桥梁
    this.bridge = new PostMessageBridge(
      this.iframe.contentWindow,
      new URL(this.url).origin
    );

    // 监听子应用事件
    this.bridge.on("navigate", (path) => {
      // 同步路由
      window.history.pushState(null, "", path);
    });
  }

  unmount() {
    if (this.iframe) {
      this.container.removeChild(this.iframe);
      this.bridge.destroy();
    }
  }
}

// 使用
const app = new MicroApp(
  document.getElementById("micro-app-container"),
  "https://sub-app.example.com"
);
app.mount();
```

### 场景三:第三方 API 调用

```javascript
// 封装 API 请求
class APIClient {
  constructor(baseURL) {
    this.baseURL = baseURL;
  }

  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;

    try {
      const response = await fetch(url, {
        ...options,
        headers: {
          "Content-Type": "application/json",
          ...options.headers,
        },
        // 根据后端 CORS 配置决定是否携带凭证
        credentials: options.credentials || "omit",
      });

      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }

      return await response.json();
    } catch (error) {
      console.error("API 请求失败:", error);
      throw error;
    }
  }

  get(endpoint) {
    return this.request(endpoint, { method: "GET" });
  }

  post(endpoint, data) {
    return this.request(endpoint, {
      method: "POST",
      body: JSON.stringify(data),
    });
  }
}

// 使用
const api = new APIClient("https://api.example.com");
api.get("/users").then((users) => console.log(users));
```

### 最佳实践建议

1. **开发环境使用代理**:配置简单,无需修改代码
2. **生产环境优先 CORS**:标准化、安全性高
3. **页面通信使用 postMessage**:安全可靠,浏览器原生支持
4. **实时通信使用 WebSocket**:性能好,功能强大
5. **统一错误处理**:封装请求方法,统一处理跨域错误
6. **环境变量管理 API 地址**:便于切换开发/生产环境
7. **安全第一**:始终验证消息来源,避免 XSS 攻击

---

## 五、常见问题排查

### 问题 1:CORS 预检请求失败

```
Access to fetch at 'https://api.example.com/users' from origin 'https://www.mysite.com'
has been blocked by CORS policy: Response to preflight request doesn't pass access control check
```

**排查步骤:**

1. 检查服务器是否处理了 OPTIONS 请求
2. 检查 `Access-Control-Allow-Methods` 是否包含实际请求方法
3. 检查 `Access-Control-Allow-Headers` 是否包含自定义请求头
4. 检查是否返回了正确的状态码(200)

**解决方案:**

```javascript
app.use((req, res, next) => {
  res.header("Access-Control-Allow-Origin", req.headers.origin);
  res.header("Access-Control-Allow-Methods", "GET, POST, PUT, DELETE, OPTIONS");
  res.header(
    "Access-Control-Allow-Headers",
    "Content-Type, Authorization, X-Custom-Header"
  );

  if (req.method === "OPTIONS") {
    return res.sendStatus(200);
  }
  next();
});
```

### 问题 2:CORS 携带 Cookie 失败

**前端:**

```javascript
fetch("https://api.example.com/users", {
  credentials: "include", // 携带 Cookie
});
```

**后端:**

```javascript
res.header("Access-Control-Allow-Origin", req.headers.origin); // 不能是 '*'
res.header("Access-Control-Allow-Credentials", "true");
```

### 问题 3:Nginx 代理后端返回 502

**常见原因:**

- 后端服务未启动
- proxy_pass 地址配置错误
- 防火墙阻止

**解决方案:**

```bash
# 检查后端服务
curl http://localhost:3000/api/users

# 查看 Nginx 错误日志
tail -f /var/log/nginx/error.log

# 测试配置
nginx -t
```

---

## 六、总结

跨域问题虽然常见,但只要理解了原理,选择合适的方案,就能轻松解决。我的个人推荐是:

1. **开发环境**: Webpack/Vite Proxy
2. **生产环境**: CORS + Nginx 反向代理
3. **页面通信**: postMessage
4. **实时通信**: WebSocket

最后,跨域只是一个技术手段,安全才是根本目的。在解决跨域问题时,一定要注意安全性,避免引入新的安全风险。

希望这篇文章能帮你彻底理解跨域问题!如果有任何疑问,欢迎交流讨论。

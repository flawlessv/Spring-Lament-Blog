字段可配置的难点在哪里（表格的合并单元格+拖动排序）
1.1.1 Table组件colSpan分组整体拖拽排序功能：
背景：目前市面上的组件库（如 Antd 等）的表格组件都提供了合并单元格以及拖拽排序的功能。假设我们的表格有20行，每5行进行合并单元格的话也就是有4组数据，我们想实现的是这四组数据能实现按组整体拖拽排序的效果。但是目前组件库尚未实现表格分组与整体拖拽排序的功能。若给表格添加拖拽排序的 API，组件库会在表格的每一行添加 draggable 属性，但 Table 组件的合并单元格仅是在视觉上合并了多行的某一列，实际上 DOM 结构仍然是多行，因此我们在拖拽的时候只能实现单行拖拽的效果。
方案一：既然拖拽的最小DOM颗粒度是单行，那我可以让同一组的表格数据渲染为一行而不是多行：

- 难点：- 相当于我们要拿着好几行的数据去自定义渲染成一个行，逻辑过于复杂，并且打破了表格的 columns 和 dataSource 数据的回显难度很大 - 表格的筛选以及增删改查都是基于行为最小颗粒度，如果我们把同一组多行的数据渲染为一行，还要对表格底层的筛选以及增删改查的逻辑进行兼容 - 表格支持手动调整列宽，我们还需要去监听各种表格dom结构/style事件的变化
  方案二：给每一组所有行绑定唯一拖拽 key
  • 为同一分组的所有行设置相同 drag-key（非 React diff key）。
  • 点击任意一行拖拽时，因整组共享同一 key，即可实现整组一起拖拽。
  此时实现了整租的拖拽效果 但是拖放操作还没实现
  1.1.1.1 方案5: 结合 dnd-kit
- 借助 useSortable 给 Table 的每一行绑定 id、style、ref、listeners 等属性。TODO:这里要解释一下dnd-kit的关键（我们用到的）api
  const Row = ({ row, rowIndex, trProps }) => {
  const { attributes, listeners, setNodeRef, transform, transition, isDragging } = useSortable({
  id: row['key'],
  transition: {
  duration: 1500,
  easing: 'cubic-bezier(0.25, 1, 0.5, 1)',
  },
  })
  const style: React.CSSProperties = {
  ...row.style,
  transform: CSS.Translate.toString(transform),
  transition,
  cursor: 'move',
  ...(isDragging ? { position: 'relative', zIndex: 9999 } : {}),
  }
  return <tr {...trProps} ref={setNodeRef} style={style} {...attributes} {...listeners} />
  }
  方案一：拖拽时整体交换目前正在拖拽的数据和目前拖拽进入的数据：在 onDragOver 事件中实时处理 dataSource、判断是向上拖动还是向下拖动->更新拖动后的顺序
  例如拖动把12拖动到34的位置，则直接把1和3交换位置，2和4交换位置即可，但是实际场景会存在很多case，例如我们正在拖动的组有3行数据，拖放结束的位置的那一组可能是4行数据或者2行数组，此时我们还要设计一个较为复杂的算法，需要分别考虑不同情况，而且这种方案在拖动的时候会实时修改多次datasource，可能存在性能问题
  方案二：只有拖动结束后才更新datasource： 大数据量处理：当表格数据量较大时，实时拖拽会导致频繁的DOM操作和数据重排：给当前正在拖动的元素添加delete 标识、如果拖动结束后符合拖动条件则删除当前正在拖动的元素，把当前元素插入到合适的位置

1. 给表格包裹上 DndContext 和 SortableContext TODO:这里要解释一下dnd-kit的关键（我们用到的）api

- 使用 DndContext 提供 sensors（用于创建传感器实例）、modifiers（用于限制拖动元素只能在垂直轴上进行移动）和 onDragOver 事件处理。
- 使用 SortableContext 并指定 strategy（一种排序策略，适用于垂直列表布局）。
  const onDragOver = ({ active, over }: DragEndEvent) => {
  // 检查是否需要交换位置->如果当前拖动元素不等于拖动时经过的元素，
  if (active.id !== over?.id) {
  // activeIndexes：当前正在拖动的row keys
  // overIndexes：当前拖动经过的row keys
  setDataSource((prev) => {
  const activeIndexes = prev
  .map((item, index) => (item.key === active.id ? index : -1))
  .filter((index) => index !== -1)
  const overIndexes = prev
  .map((item, index) => (item.key === over?.id ? index : -1))
  .filter((index) => index !== -1)
  // 判断边界条件，如果元素拖出表格则直接return 不用改变dataSource
  if (activeIndexes.length <= 0 || overIndexes.length <= 0) return prev
  // 定义dataSource交换数据函数
  function swapSegments(arr: any[], activeIndexes: number[], overIndexes: number[]): any[] {
            return finalArray
          }
          return swapSegments(prev, activeIndexes, overIndexes)
        })
      }
  }
  字段可配置是在重构数据时是怎么做的？
  将字段 JSON 解析为三个结构化维度：
- UI描述 (uiProperties)：控制显示行为（showInTable/showInDetail/showInCreate、宽度布局等）
- 数据模型 (metaProperties)：定义业务属性（默认是、fieldEnums等）
- 规则校验 (actionProperties)：控制交互行为（editable、rules、依赖关系等）
  第二阶段：字段处理与存储
  分类与分组：
- 按页面场景分类：表单字段、表格字段、详情字段
- 按业务场景分类：这里不多赘述
- 按来源分类：可配置字段、不可配置字段
  统一管理字段依赖关系：自定有Hook去编辑字段配置的JSON，把所有依赖字段收集到一个Map结构里，key为当前字段，value为当前字段依赖的字段以及字段的详细信息，使得字段依赖查找的复杂度从On变为O1
  第三阶段：表单/详情/或者表格列配置生成（这里拿表格举例）
  类型映射：建立字段类型→UI组件的映射表，运行时自动拼装props和渲染逻辑配置生成：
- 基础列配置：字段编码、标题、列宽、对齐方式
- 过滤器映射：根据valueType确定筛选器组件类型，比如Text就是模糊搜索筛选，Select就是下拉勾选筛选
- 渲染器映射：比如Text就是简单文本渲染，支持溢出省略悬浮提示，多选字段：将多个值用逗号连接，支持悬浮提示
- 枚举值处理：- 合并不同需求类型下的枚举值 - 解决一对多编码映射问题（codes数组用逗号连接）
  第四阶段：组装与优化
  最终装配：
- 添加操作列以及不可配置的字段（创建人、创建时间等）
  字段可配置的级联枚举是如何做的（分配置和应用）
  首先从配置层面来说：
- 脱离Form控制：配置枚举的逻辑过于复杂，为了保证代码规范，必须单独抽离组件，但这样就脱离了form的统一状态管理。透传value&onchang事件；通过useControllableValue实现受控与非受控的平滑切换，既保持了组件的独立性，又确保数据能正确回流到父级Form
  1.2 多层校验规则设计
- 交互：如果一个字段选了另一个字段作为前置字段，我需要去获取前置字段的枚举来渲染到当前的字段配置页作为枚举配置的第一层级，然后可以在每一个前置枚举下配置若干后置枚举
  - 枚举值去重逻辑：防止形成循环引用，每个字段只能依赖一个前置字段、前置字段必须至少包含一个有效的枚举值、同一父级下不能出现重复枚举，不同父级下可以出现重复枚举，这些校验也是封装到了一个统计校验的hook
- 智能导入机制：支持Excel批量导入级联枚举，自动识别缺失的父级枚举并触发创建
  其次从渲染层面来说：
  2.1 依赖关系映射构建
- 预处理阶段：通过useGetPreFieldsMap遍历收集所有字段的依赖关系，构建高效的Map数据结构
  2.2 动态组件渲染策略
- 类型映射机制：建立字段类型到组件的映射关系，在渲染时判断是否为级联字段
- 高阶组件封装：对级联字段包装高阶组件，统一处理以下逻辑：
  - 禁用状态控制：当前置字段未选择时，子字段自动禁用
  - 动态枚举更新：前置字段变化时，实时更新子字段的可选项
  - 联动清空逻辑：前置字段重新选择时，清空子字段的已选值
    字段可配置是如何保障重构后数据一致性的
  1. 原本的数据是by版本保存的字段，本来有20多个版本，每个版本下有几十个字段
  2. 我实现一个一个人工收集了一个版本的字段信息，包括字段类型以及字段属性等，然后利用AI+代码上下文+样本提示帮我说生成了所有版本的所有字段信息
  3. 测试会拿着线上的字段数据以及属性对照测试环境的字段、产品最终review
     如果再来一次，有哪些改进的地方
  4. 由于经验不足，所以在前期设计字段可配置的架构的时候没有以全局的视角看问题，导致后续开发增加了一些工作量
  5. 字段配置和字段渲染在 统一收集字段依赖关系的工具函数/hook中 有大部分逻辑耦合，但是刚开始先做的字段配置就没考虑到字段渲染层面需要的结构以及数据，导致后续改造起来有点困难只能再重新做一套收集的逻辑
  6. 字段的枚举应该单独渲染以及获取+懒加载的方式，因为枚举的数量太多了
     从0到1做项目，对自己最大的提升是什么

1. 业务理解的深度提升
   从功能思维转向业务思维

- 之前：拿到需求就想着怎么实现，关注的是"做什么"
- 现在：会深挖需求背后的业务本质，思考"为什么要这么做？

2. 技术方案设计的全局视野
   从单点优化到系统性思考

- 技术债务意识：每个技术决策都会考虑长期维护成本
- 性能预估能力：能够在设计阶段就预判性能瓶颈
- 兼容性设计：考虑新老系统的平滑过渡
  方案评估框架的建立
  形成了一套相对成熟的技术方案评估标准：

1. 可行性：技术实现的复杂度和风险
2. 扩展性：未来需求变化的适应能力
3. 维护性：代码的可读性和可调试性
4. 性能影响：对系统整体性能的影响
5. 开发效率：开发和测试的时间成本
6. 架构设计的系统性思维
   分层设计能力
   学会了把复杂系统拆分成清晰的层次：

- 数据层：字段配置的存储和查询
- 业务层：字段依赖关系的处理逻辑
- 服务层：配置的版本管理和权限控制
- 展示层：动态表单的渲染和交互
  设计模式的实际应用
  理解了什么场景下用什么模式：
- 策略模式：处理不同字段类型的渲染逻辑
- 观察者模式：字段间的联动关系
- 工厂模式：字段组件的动态创建
  业务建模能力
  学会了把复杂的业务规则抽象成可操作的数据模型。比如把"字段依赖关系"这种抽象概念，转化为具体的配置项和校验规则。

4. 解决问题能力的质变
   问题定位能力

- 系统性排查：从用户反馈到系统日志，建立完整的问题追踪链路
- 假设驱动：快速建立假设并验证，而不是盲目尝试
- 工具化思维：为常见问题开发调试工具，提升排查效率
  风险预判能力
- 技术风险：新技术栈的不确定性
- 业务风险：需求变更的可能性
- 资源风险：人力和时间的约束
  沟通协调能力
  技术问题往往不是纯技术问题，学会了：
- 向上管理：把技术问题转化为业务语言，让领导理解
- 跨团队协作：协调前端、后端、测试、产品等不同角色
- 外部沟通：与业务方的需求澄清和方案讲解

5. 其他重要提升
   项目管理意识

- 节奏控制：学会拆分里程碑，控制项目节奏
- 质量把控：建立代码评审、测试用例等质量保障机制
- 文档意识：重视设计文档和用户手册的价值
  技术视野的扩展
- 开源生态：了解了更多开源解决方案，学会站在巨人肩膀上
- 行业趋势：关注技术发展趋势，避免技术选型的短视
- 最佳实践：总结了一套适合团队的开发规范和流程
  学习能力的进化
- 快速学习：面对新技术能够快速上手并应用到项目中
- 知识体系化：把零散的知识点整合成完整的技术体系
- 持续改进：项目结束后的复盘和总结，为下次项目积累经验
  怎么利用Vibe Coding + MCP实现的，思路是什么

2. 自己先拆分好代码结构、组件怎么拆分、API层、工具函数层、Store层等
3. 然后利用figma mcp去实现大致的dom结构，再通过手动调整/AI工具去改样式
4. 对于比较难的业务逻辑和模块，自己先让AI写一个插槽但不具体实现，想出来方案设计，然后去问AI怎么样有没有可以修改的地方以及其他方案，最后选一个最优的让AI去实现
   怎么进行的（AI 单测）Prompt设计、调优

- 背景：现在大家用AI生成单测代码时暴露出多个关键问题：
  - 准确率不稳定：同类测试场景下输出结果存在20-30%的波动率
  - 指令冗余严重：Prompt长度超过2000tokens，包含大量重复和无效指令
  - 高频错误重复：相同类型的逻辑错误在不同测试场景中反复出现
- T : 设计并调优AI单测Prompt 2.0版本，实现以下目标：
  - 提升AI生成单测代码的准确性和稳定性
- A :一个生产级别的Prompt一定要采用结构化格式标准
  尤其是使用markdown、 json、yaml 这类成熟的数据结构，对 prompt 进行工程化开发特别友好。1. 优势一：1. 结构化Prompt不仅结构清晰，可读性强，也便于人与模型理解2. 优势三：定向唤醒大模型深度能力1. 一级标题使用Role属性词定向唤醒模型角色扮演能力，添加Rules、Constraints等词确保模型遵守特定规则，提升模型表现。3. 优势四：像代码开发一样构建生产级 Prompt
  在现代软件开发中，Prompt的作用越来越类似于编程语言，尤其是在调用大型语言模型的能力时。

2. 如何写好结构化 Prompt ?
   当我们构建结构化 Prompt 的时候，我们在构建什么？什么是真正重要的事情？
   2.1 构建全局思维链
   一个好的结构化 Prompt 模板，某种意义上是构建了一个好的全局思维链。 如
   Role (角色) -> Profile（角色简介）—> Profile 下的 skill (角色技能) -> Rules (角色要遵守的规则) -> Workflow (满足上述条件的角色的工作流程) -> Initialization (进行正式开始工作的初始化准备) -> 开始实际使用
   一个好的 Prompt ，内容结构上最好也是逻辑清晰连贯的。结构化 prompt 方法将久经考验的逻辑思维链路融入了结构中，大大降低了思维链路的构建难度。
   Workflow：链式思考机制引入 - 分析阶段：理解组件功能和业务逻辑 - 设计阶段：制定测试策略和用例结构 - 实现阶段：编写具体测试代码 - 验证阶段：检查测试完整性和正确性

- Rules：- 单测代码运行在Node环境，碰到业务代码中用到window的api必须mock - 碰到业务代码中的异步部门必须用waitfor去等待
  调优：模块间相互独立、Case完全穷尽、迭代上小步快跑 - 通过迭代测试循环优化、MECE原则精简指令、1. MECE原则指令精简 - Mutually Exclusive（相互独立）：确保指令间无重叠和冲突 - Collectively Exhaustive（完全穷尽）：覆盖所有关键测试场景
- R :成功发布生产级AI单测Prompt 2.0版本，显著提升测试准确率和稳定性，减少高频错误重复。
  AI PageTable MCP工具开发的思路（这个方案已经废弃、转为了 CC的Skills方案）
  mcp跟skills的区别？
  先说下背景，我跟一位同事共同开发了一个面向切面编程的组件库，这个组件库采用了DSL的思想，定义一些配置例如表格的columns的时候支持很简洁的语法并且支持链式调用，此外还支持可编辑的特性。组件库主要分为三大块、表单、表格、描述。但是很多同学可能对这种简洁的语法不熟悉，并且这种语法就天然的和Vibe coding相结合，所以我们就想做一个AI pagetable 的mcp服务，例如想开发一个表格页，直接在cursor里调用mcp服务并且prompt说我想实现一个表格页，哪些字段的哪些属性例如文本、下拉等等，以及表格的一些属性，例如分组、排序等等。之后大模型就会调用mcp服务把这些propmpt作为mcp tools的参数传给我，我接收到这些指令的时候第一想法是把字段定义以及表格功能的api用法传给LLM，然后让LLM去生成代码，但是调试了几轮之后发现效果不理想。然后我就想到了propmpt的一个case就是把一些案例给LLM，同时也去看了几个开源的组件库的mcp服务发现他们也都是把对应功能的源码直接给了LLM。所以我也在mcp服务里维护了一个映射，例如收到指令为分组或者分类等等，就会把我们组件库分组表格的案例的全部代码+拼装一些必要的prompt饭给大模型，发现效果还不错
- S: @mi/schema-components组件使用时字段定义的DSL学习成本高、开发效率低、文档查找繁琐
- T：设计并实现基于MCP协议的智能表格代码生成服务，通过Few-Shot Learning机制实现自然语言到DSL的精准转换
- A: 构建智能文档处理引擎，支持关键词提取、模式匹配、功能排除等核心算法
- R: 实现了自然语言到组件库DSL字段定义/表格Feature功能的自动转换 & 表格使用API文档

3. 什么是面向切面编程？说说组件库设计的核心思想

- 概念：面向切面编程（AOP，Aspect-Oriented Programming）是一种编程范式，它通过将横切关注点（Cross-cutting Concerns）从主业务逻辑中分离出来，实现关注点的分离
  所谓横切关注点，指的是那些贯穿整个应用程序的功能，如日志记录、性能监控、权限验证、错误处理等。这些功能往往散布在系统的各个部分，导致代码重复和难以维护
  AOP提供了一种方案，允许我们定义"切面"（Aspect）来封装这些关注点：

1. 面向对象编程（OOP, Object-Oriented Programming）

- 核心思想：通过对象（类）封装数据和行为，强调继承、多态和封装。
- 典型语言：Java、C++、Python、C#。

---

2. 函数式编程（FP, Functional Programming）

- 核心思想：将计算视为数学函数的求值，避免状态变更和可变数据，强调纯函数、高阶函数和不可变性。
- 典型语言：Haskell、Lisp、Scala、Clojure、JavaScript（部分支持）。

---

3. 过程式编程（Procedural Programming）

- 核心思想：通过一系列步骤（过程或函数）解决问题，强调代码的线性执行和模块化。
- 典型语言：C、Pascal、Fortran。

---

4. 声明式编程（Declarative Programming）

- 核心思想：描述“做什么”而非“如何做”，由系统决定具体实现。
- 子范式：
  - 逻辑编程（如Prolog）：通过规则和事实描述问题。
  - 函数式编程（部分属于声明式）。
  - 数据库查询语言（如SQL）：声明查询条件而非实现细节。

---

5. 响应式编程（Reactive Programming）

- 核心思想：处理异步数据流（如事件、消息），强调数据变化时的自动响应。
- 典型语言/框架：RxJS（JavaScript）、ReactiveX、Spring WebFlux。
- 关键概念：- 观察者模式：数据生产者与消费者的解耦。- 数据流：事件序列的抽象。
  设计思想（怎么切面的）：
- 字段模型配置
  - 字段标题
  - 数据Key
  - 字段类型
  - 底层组件Props
  - 包裹组件Props
  - 表单项组件Props
  - 自定义渲染器
- 字段组件渲染逻辑
  - 只读模式
  - 表格单元格模式
  - 表单项模式
- 渲染器组件逻辑
  - Table
  - Descriptions
  - Form: TODO
- 字段配置生成器
- 难点：
  如何用AI去写代码的
  Cursor:
  Claude code:
  Vibe Coding的最佳实践是：
  如何衡量一个需求能否用AI实现：
- 能否接受一定的不确定性和模糊性
- 收益成本对等吗
- 是一个可以接受逐步的迭代和性能提升的场景吗
  xxxxxvsxxxx
